\section{Morphisms of arrow-based conditions}

The notion of \emph{morphism} of nested conditions has not received much attention in the literature. When considered at all, such as in \cite{Koenig-morphism}, they are essentially based on the semantics in terms of satisfaction. Indeed, entailment establishes a preorder over conditions, which is a category in which there is a (unique) arrow between conditions if and only if the source entails the target. \todo{Is there a standard name for this interpretation?} Let us denote this category $\ABC^{\entails}$.

The question that we address in this section is to establish a meaningful \emph{structural} notion of condition morphism. That is, given the fact that an ab-condition is essentially a diagram in the category $\bC$, a structural morphism from $b$ to $c$ consists of arrows between objects of $b$ and objects of $c$ satisfying certain commutativity conditions. For morphisms to be meaningful, they should certainly only exist where there is entailment; in other words, we require there to be a functor to $\ABC^{\entails}$. As we will see, this requirement implies that it is not enough to consider only arrows from objects of $b$ \emph{to} objects of $c$, since in our definition of satisfaction, the direction of entailment flips at every subsequent nesting level. We also observe that the existence of a functor to $\ABC^{\entails}$ means that we only consider morphisms between conditions with the same root.

In this section and the next, we will review several candidate notions of morphism, but the underlying principle is always the same: a morphism $m$ from $b=(R,p^b_1\ccdots p^c_{|b|})$ to $c=(R,p^c_1\ccdots p^c_{|c|})$ must identify, for every $b$-branch $p^b_i$, a $c$-branch $p^c_j$ that entails it. Entailment of branches, in turn, is captured by the existence of an arrow $v_i$ from $P^c_j$ to $P^b_i$ (hence going in the \emph{opposite} direction of $m$) such that, \emph{modulo $v_i$}, there is a morphism between the subconditions $c_j$ and $b_i$. The main task is to make the concept of ``modulo $v_i$" precise, allowing to relate conditions rooted at different objects.

\subsection{Change of root}

We will first define what it means to ``change the root" of an arrow; this will be extended later to conditions.
%
\begin{definition}[source shifter]\dlabel{source shifter}
Let $v:A\to B$ be an arrow. A \emph{source shifter} $\cS$ for $v$ is a binary relation between $A$-sourced arrows and $B$-sourced ones having the same target, such that $(a,a')\in \cS$ implies
%
\begin{equation}\eqlabel{shift preservation}
\text{ for all } g: \enspace v;g=a;h \text{ implies } g=a';h \enspace.
\end{equation}
%
$\cS$ is a \emph{forward source shifter} if it is functional, i.e., for all $a:A\to C$ there is exactly one $a':B\to C$ such that $(a,a')\in \cS$ (we denote $a'=\forw\cS(a)$), and moreover, $\forw\cS(a);t=\forw\cS(a;t)$ for all $t:C\to D$.

$\cS$ is a \emph{backward source shifter} if its inverse is functional; i.e., for all $a:B\to C$ there is exactly one $a':A\to C$ such that $(a',a)\in \cS$ (we denote $a'=\back\cS(a)$), and moreover, $\back\cS(a;t)=\back\cS(a);t$ for all $t:C\to D$.
\end{definition}
%
The preservation property \eqref{\eqprf:shift preservation} as well as the principle of forward and backward source shifting are visualised in \fcite{shifter-properties}.
%
\begin{figure}
\centering
\subcaptionbox{Preservation (\eqcite{shift preservation})}[.3\textwidth]
              {\input{figs/shift-preservation}}%
\subcaptionbox{Forward source shift}[.35\textwidth]{\input{figs/forward-shift}}%
\subcaptionbox{Backward source shift}[.35\textwidth]{\input{figs/backward-shift}}%
\caption{Visualisation of source shifter properties ($\cS$ a source shifter for $v$)}
\flabel{shifter-properties}
\end{figure}

Source shifting is extended to conditions, where it is called \emph{root shifting}. Let $v:A\to B$, and let $\cS_1\ccdots \cS_w$ be a sequence of source shifters for $v$.
%
\begin{itemize}
\item $\cC[\cS_1\ccdots \cS_w]$, a \emph{root shifter for $v$}, is a relation between $\AC A$ and $\AC B$ such that $(b,c)\in \cC[\cS_1\ccdots \cS_w]$ if $|b|=|c|=w$ and for all $1\leq i\leq w$, $(a^b_i,a^c_i)\in \cS_i$ and $b_i=c_i$. We say that $\cC[\cS_1\ccdots \cS_w]$ has \emph{width $w$}.
\item $\cC[\cS_1\ccdots \cS_w]$ is called forward [backward] if all $\cS_i$ are forward [backward]. Note that, in that case, [the inverse of] $\cC[\cS_1\ccdots \cS_w]$ is indeed again functional.
\end{itemize}
%
We use $\cC$ to range over root shifters always obtained from a sequence of source shifters, as above), and $|\cC|$ to denote the width of $\cC$. Note that root shifting \emph{only} changes the root, i.e., the source of the first level of arrows: all subconditions remain the same. This is visualised in \fcite{root shifting}.
%
\begin{figure}
\centering
\input{figs/root-shifting.tex}
\caption{Root shifting: $(b,c)\in \cC[\cS_1\ccdots \cS_w]$ for $v:A\to B$}
\flabel{root shifting}
\end{figure}
%
The semantics of the root-shifted condition is ``equivalent modulo $v$" to the original one, in the following sense: 
%
\begin{proposition}
If $\cC$ is a root shifter for $v$, then $(b,c)\in \cC$ implies
\[ \text{ for all } g: \enspace v;g\sat b \text{ if and only if } g\sat c \enspace. \]
\end{proposition}
%
\begin{proof}
Assume $v:A\to B$, $\cC=\cC[\cS_1\ccdots \cS_w]$ and assume $(b,c)\in \cC$. For all $1\leq i\leq w$, due to $(a^b_i,a^c_i)\in \cS_i$ we know that $b_i=c_i$ and, for all $g:B\to G$ and $h:P^c_i\to G$, $a^b_i;h= 
\begin{description}
\item[If:] Assume $g\sat c$; then there is a witness $h$ and a responsible branch $p^c_i$ such that $g=a^c_i;h$ and $h\nsat c_i$. But then (due to $(a^b_i,a^c_i)\in \cS_i$) $a^b_i;h=v;g$ and $h\nsat b_i$, hence $h$ is also a witness for $v;g\sat b$ (with responsible branch $p^b_i$).

\item[Only if:] Assume $v;g\sat b$; then there is a witness $h$ and a responsible branch $p^c_i$ such that $v;g=a^b_i;h$ and $h\nsat c_i$. 
\qed
\end{description}
\end{proof}
%
Since root-shifting is defined on a branch-by-branch basis, for zero-width conditions (encoding the property $\False$ over their respective roots) there is essentially no requirement to be fulfilled. Hence, the single pair $\cI_{A,B}=\setof{((A,\epsilon),(B,\epsilon))}$ is both a forward and a backward zero-width root shifter for any $v:A\to B$.

Shifters compose; that is, the following holds for both source and root shifters.
%
\begin{proposition}
If $\cT$ is a shifter for $u:A\to B$ and $\cU$ a shifter for $v:B\to C$, then $\cT;\cU$ (understood as relation composition) is a shifter for $u;v$. Moreover, if both $\cT$ and $\cU$ are forward [backward], then $\cT;\cU$ is forward [backward].
\end{proposition}

\subsection{Epi- and retraction-based shifting}

We now define two concrete, independent notions of (source and root) shifting. 
Let $v:A\to B$ be an arrow.
\begin{itemize}
\item If $v$ is epi, then the relation $\cE_v$ (between $A$- and $B$-sourced arrows to the same target) is defined by:
\[ (a_1,a_2)\in \cE_v \text{ if } a_1=v;a_2 \enspace.
\]
\item If $v$ is a retraction with section $s$ (i.e., such that $s;v=\id$), then the relation $\cR_v^s$ (between $A$- and $B$-sourced arrows to the same target) is defined by:
\[ (a_1,a_2)\in \cR_v^s \text{ if } a_2=s;a_1 \enspace.
\]
\end{itemize}
%
We will show that these relations, which we call epi-based and retraction-based, are, respectively, backward and forward source shifters. The underlying principles are visualised in \fcite{source shifters}.
%
\begin{figure}
\centering
\input{figs/source-shifting}
\caption{Epi-based and retraction-based source shifting (all subdiagrams commute)}
\flabel{source shifters}
\end{figure}

\begin{proposition}
Let $v$ be an arrow.
\begin{enumerate}
\item If $v$ is epi, then $\cE_v$ is a backward source shifter for $v$.
\item For all $s;v=\id$, then $\cR_v^s$ is a forward source shifter for $v$.
\end{enumerate}
\end{proposition}
%
Note that the existence of $s$ such that $s;v=\id$, as required for $\cR_v^s$, implies that $v$ is epi, as required for $\cE_v$; nevertheless, it is not the case that $\cR_v^s\subseteq\cE_v$: the commutativity conditions cause these source shifters to be independent.\todo{Insert example here?}

A retraction may have more than one section, and when root-shifting a condition, we may use different source shifters for its branches. Epi-based shifting is less complex in that (for any width) we have at most one epi-based root shifter for any given arrow (namely, one if the arrow is epi or the width is zero, and none otherwise). For any width $w$, we introduce the following special root shifters:
\begin{itemize}
\item $\cR_v^{s_1\ccdots s_w} = \cC[\cR_v^{s_1}\ccdots \cR_v^{s_w}]$ with all $s_i$ sections of $v$;
\item $\cE^w_v= \cC[\underbrace{\cE_v\ccdots\cE_v}_w]$ with $v$ epi.
\end{itemize}
%
Note that, as as a consequence of the observation above regarding zero-width root shifters, $\cR_v^\epsilon=\cE_v^0=\cI_{A,B}$.

\subsection{Structural morphisms}

The following defines structural morphisms based on root shifters.

\begin{definition}[arrow-based condition morphism]\dlabel{ab-morphism}
  Given two ab-conditions $b$ and $c$, a \emph{forward-shift [backward-shift] condition morphism} $m: b \to c$ is a pair $(o,(v_1,m_1)\ccdots (v_{|b|},m_{|b|}))$ where
  \begin{itemize}
  \item $o:[1,|b|]\to[1,|c|]$ is a function from $b$'s branches to $c$'s branches;
  \item for all $1\leq i\leq |b|$, $v_i:P^c_{o(i)}\to P^b_i$ is a mapping from the pattern of $p^c_{o(i)}$ to that of $p^b_i$ such that $a^c_{o(i)};v_i=a^b_i$;
  \item\emph{Forward shift}: for all $1\leq i\leq |b|$, there is a forward root shifter $\cC_i$ for $v_i$ such that $m_i:\forw{\cC_i}(c_{o(i)})\to b_i$ is a forward-shift morphism.
  \item\emph{Backward shift}: for all $1\leq i\leq |b|$, there is a backward root shifter $\cC_i$ for $v_i$ such that $m_i:c_{o(i)}\to \back{\cC_i}(b_i)$ is a backward-shift morphism.
  \end{itemize}
\end{definition}
%
\fcite{shifted-morphism} visualises the principle of forward- and backward-shift morphisms (on a single branch).
%
\begin{figure}
\centering
\input{figs/shifted-morphisms}
\caption{Forward-shift and backward-shift morphism $m:b\to c$}
\flabel{shifted-morphism}
\end{figure}

\begin{proposition}
$\ABC$ endowed with either forward-shift or backward-shift morphisms give rise to a category that embeds into $\ABC^{\entails}$.
\end{proposition}
%
Putting all these elements together, $\ABC$ can be meaningfully endowed with two concrete kinds of morphisms:

\begin{itemize}
\item Forward-shift morphisms using retraction-based shifting (or \emph{retraction-based morphisms} for short).
\item Backward-shift morphisms using epi-based shifting (or \emph{epi-based} morphisms for short).
\end{itemize}
%
There is no unequivocal evidence which one of these is the ``best" or ``most useful". For example, when instantiating arrow-based conditions in the category of cospans (as advocated by \cite{Koenig et al}), the notion of retraction-based morphism is all but useless, because in that category, only trivial cospans (in which both legs are epi) can be retractions. On the other hand, when we move to span-based conditions in the sequel, it will turn out out that retraction-based morphisms extend naturally whereas epi-based morphisms do not.

