\section{Arrow-based conditions}
\slabel{ab-conditions}

In this section we recall the standard notion of nested condition from~\cite{Rensink-FOL}, using notations that will make the connection with the variation proposed in this paper as straightforward as possible. Here and in the remainder of the paper, we will mostly omit the term ``nested'' and just refer to \emph{conditions}; however, to distinguish between variations upon this theme, we will refer to the standard notion of nested conditions as \emph{arrow-based}.

Along the paper examples and intuitions will be based on $\cat{Graph}$, the category of directed, edge-labelled multigraphs. However, formal definitions and results will be phrased in terms of objects and arrows of a generic category $\bC$ that we assume to be a \emph{presheaf topos}, i.e., a category of contravariant functors from a small category \cat{S} to \cat{Set}, thus \cat{C} $= [\op{\cat{S}} \to \cat{Set}]$. Several categories of graphs and hypergraphs are presheaf toposes: for example, directed unlabeled graphs are obtained with \cat{S} the free category generated by $\mygraph{
  \node (1) {$\bullet$};
  \node (2) [right=of 1] {$\bullet$};
  \path (1) edge[bend left=20,->] (2)
        (1) edge[bend right=20,->] (2);
}$. Furthermore, presheaf toposes are closed under the construction of slice and functor categories, thus they include labeled/typed (hyper)graphs (see Sec.~5 of~\cite{AzziCR19}). We will denote the collection of objects of $\cat{C}$ by $|\cat{C}|$, and for $A,B \in |\cat{C}|$ we denote by $\cat{C}(A,B)$ the (hom)set of arrows from $A$ to $B$.  

Assuming that \cat{C} is a presheaf topos ensures several properties we need in the constructions of this paper: in particular, that all limits and colimits exist (and can be computed pointwise), and also that epis are stable under pullback. Furthermore, \cat{C} is \emph{adhesive}~\cite{ls:adhesive-journal}, enjoying several properties exploited in the algebraic theory of graph rewriting, where the results of this paper have potential interesting applications.\footnote{Note that requiring \cat{C} to be just adhesive would not suffice: for example, we need arbitrary pushouts, while adhesivity only guarantees pushouts along monos.}

\medskip\noindent
Arrow-based conditions are inductively defined as follows:

\begin{definition}[arrow-based condition]\dlabel{ab-condition}
  Let $R$ be any object of $\bC$. $\AC R$ (the set of \emph{arrow-based conditions} over $R$) and $\AB R$ (the set of \emph{arrow-based branches} over $R$) are the smallest sets such that
  \begin{itemize}
  \item $c\in \AC R$ if $c=(R,p_1\ccdots p_w)$ is a pair with $p_i\in \AB R$ for all $1\leq i\leq w$, where $w \geq 0$;
  \item $p\in \AB R$ if $p=(a,c)$ where $a: R\to P$ is an arrow of $\bC$ and $c\in \AC P$.
  \end{itemize}
\end{definition}
%
We regularly abbreviate ``arrow-based" to ``ab". We call $R$ the \emph{root} of an ab-condition or ab-branch, and $P$ the \emph{pattern} of an ab-branch (which is simultaneously the root of its subconditon). \fcite{ab-condition} provides a visualisation of an ab-condition $c$. We use $b,c$ to range over ab-conditions and $p,q$ to range over ab-branches. We use $|c|=w$ to denote the width of an ab-condition $c$, $R^c$ to denote its root, and $p^c_i=(a^c_i,c_i)$ its $i$-th branch. Finally, we use $P^c_i$ ($=R^{c_i}$) for the pattern of branch $p^c_i$. In all these cases, we may omit the superscript $c$ if it is clear from the context.
%
\begin{figure}[t]
\centering
\subcaptionbox
  {Condition $c=(R,p_1\ccdots p_w)$, with $p_i=(a_i,c_i)$ for $1\leq i\leq w$
   \flabel{ab-condition}}
  [.45\textwidth]
  {\input{figs/ab-condition}}
\quad
\subcaptionbox
  {$g\sat c$, with responsible branch $p_i=(a_i,c_i)$ and witness $h$ such that $g=a_i;h$
   \flabel{ab-satisfaction}}
  [.5\textwidth]
  {\input{figs/ab-satisfaction}}
\caption{Visualisations for arrow-based conditions}
\end{figure}

Note that, as a consequence of the inductive nature of \dcite{ab-condition}, every ab-condition has a finite \emph{depth} $\depth(c)$, defined as $0$ if $|c|=0$ and $1+\max_{1\leq i\leq |c|} \depth(c_i)$ otherwise. The depth will provide a basis for inductive proofs.

\begin{example}\exlabel{ab-conditions}
\fcite{ab-conditions} depicts three arrow-based conditions, rooted in the discrete one-node graph \inline{\onenode x}. According
to the notion of satisfaction introduced below, assuming that we already know the image of $x$ in a graph, the properties can be expressed as follows in FOL:
\begin{itemize}
\item $c_1$ is equivalent to $\lb(x,x)\wedge \nexists y\st(\la(x,y)\vee \lc(x,y))$
\item $c_2$ is equivalent to $\exists y\st \lb(x,y) \wedge \neg \la(y,y)\wedge \neg \exists z\st \lc(y,z)$ 
\item $c_3$ is equivalent to $\la(x,x)\vee (\exists y\st \lb(x,y) \wedge (\forall v,z\st \lc(y,v)\wedge \lc(y,z) \rightarrow v=z))$
\end{itemize}
%
Note that we have used variable names to represent nodes, to make the connection to the corresponding FOL properties more understandable. The morphisms are in all cases implied by the graph structure and variable names.
\qed
\end{example}
%
\begin{figure}[t]
\centering
\input{figs/ex-ab-conditions}
\caption{Examples of arrow-based conditions (see \excite{ab-conditions})}
\flabel{ab-conditions}
\end{figure}

\subsection{Satisfaction}

A condition expresses a property of arrows from its root to an arbitrary object. This is operationalised through the notion of \emph{satisfaction}.

\begin{definition}[satisfaction of arrow-based conditions]\dlabel{ab-satisfaction}
  Let $c$ be an ab-condition over $R$ and $g:R\to G$ an arrow from $c$'s root to some object $G$. We say that \emph{$g$ satisfies $c$}, denoted $g\sat c$, if there is a branch $p_i=(a_i,c_i)$ of $c$ and an arrow $h:P_i\to G$ such that
  \begin{enumerate*}
  \item $g=a_i;h$ and
  \item $h\nsat c_i$.
  \end{enumerate*}
\end{definition}
%
If $g\sat c$, we also say that $g$ is a \emph{model} for $c$. We call $p_i$ the \emph{responsible branch} and $h$ the \emph{witness} for $g\sat c$. Pictorially, $g\sat c$ with responsible branch $p_i$ and witness $h$ can be visualised as in \fcite{ab-satisfaction}.

Based on the notion of satisfaction, for ab-conditions $b$ and $c$ (over the same root) we also define \emph{semantic entailment} $b\entails c$ and \emph{semantic equivalence} $b\equiv c$:
%
\begin{align*}
b \entails c & \text{ if for all arrows $g$: } g\sat b \text{ implies } g\sat c \\
b \equiv c & \text{ if for all arrows $g$: } g\sat b \text{ if and only if } g\sat c \enspace. 
\end{align*}

\begin{example}\exlabel{ab-satisfaction}
Let us consider some models for the ab-conditions in \fcite{ab-conditions}.
\begin{itemize}[topsep=0pt]
\item Let $G_1=\myinlinegraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\lc} (1);
}$
and let $g$ be the morphism from the one-node discrete graph \inline{\onenode x} to the left-hand node of $G_1$. It is clear that $g\nsat c_1$ because there is no witness for $c_{11}$ ($G_1$ does not have the required $\lb$-loop). Instead, we have $g\sat c_2$: the witness $h$ (for $c_{21}$) maps $y$ to the right-hand node of $G_1$; and $h$ does not satisfy the subconditions of $c_{21}$ because it cannot be extended with either the $\la$-loop specified by $c_{211}$ or the outgoing $\lc$-edge specified by $c_{212}$. Similarly, $g\sat c_3$.

\item Let $G_2=\myinlinegraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\node (3) [right=of 2] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\la} (1)
      (2) edge[->] node[above] {\lc} (3);
	  }$
and let $g,g',g''$ be the morphisms from \inline{\onenode x} to $G_2$ mapping \inline{\onenode x} to the left, mid and right node of $G_2$, respectively. None of these models satisfy $c_1$, for the same reason as above. Moreover, none satisfy $c_2$: though $g$ and $g'$ have witnesses for $c_{21}$, these are ruled out by either $c_{212}$ (in the case of $g$) or $c_{211}$ (in the case of $g'$); $g''$ not even has a witness for $c_{21}$. Instead, both $g\sat c_3$ (in fact there are two distinct witnesses, one for $c_{31}$ and one for $c_{32}$) and $g'\sat c_3$ (due to $c_{32}$); but again $g''\nsat c_3$.

\item If $G_3=\inline{\oneloopleft \bullet b}$, then the only morphism $g$ from \inline{\onenode x} to $G_3$ has $g\sat c_1$, $g\sat c_2$ and $g\sat c_3$. 
\end{itemize}
In general, it can be checked that every model of $c_1$ is also a model of $c_2$ and every model of $c_2$ is a model of $c_3$, thus $c_1\entails c_2$ and $c_2 \entails c_3$. On the other hand, $c_2\nsat c_1$ as shown by $g:\inline{\onenode x}\to G_1$, and $c_3 \nsat c_2$ as shown by $g:\inline{\onenode x}\to G_2$.\qed
\end{example}

\subsection{Connection to first-order logic}

It has been shown (e.g., \cite{Rensink-FOL,Habel-FOL}) that every first-order logic (FOL) formula can be encoded as an arrow-based nested condition over $\Graph$ and vice versa. For the sake of completeness, we summarise the connection here. We restrict to binary predicates, which we take from the set of edge labels $\Lab$. For the purpose of this discussion, w.l.o.g.\ we assume that graph nodes are variables, taken from $\Var$.

The syntax of FOL that we use is given by the grammar
%
\[ \phi \:::=\: \True
        \:\mid\: \False
		\:\mid\: \la(x_1,x_2)
        \:\mid\: x_1=x_2
		\:\mid\: \phi_1\wedge \phi_2
		\:\mid\: \phi_1\vee \phi_2
		\:\mid\: \neg\phi_1
		\:\mid\: \exists \bar x\st \phi_1 
		\]
where the $x_i$ are variables (from $\Var$), $\bar x\in \Var^*$ is a finite sequence of distinct variables and $\la$ is a binary predicate. We also use the concept of \emph{free variables} of $\phi$, denoted $\fv(\phi)$, inductively defined in the usual way.

Just as for conditions, the semantics of FOL is defined through a notion of satisfaction; however, the models are not arbitrary arrows in $\Graph$ but \emph{valuations} that map variables to the nodes of a graph. Such a valuation can be seen as an arrow from the discrete graph with node set $X\subseteq \Var$, here denoted $D_X$. Hence, the models of a formula $\phi$ are arrows $v:D_X\to G$ (for some $X\supseteq \fv(\phi)$ and some graph $G$) such that $v\sat^\FOL \phi$. For an arbitrary graph $A$ with node set $X_A$, let $v_A:D_{X_A}\to A$ map the discrete graph over $X_A$ to $A$.

Theorems 1 and~3 of \cite{Rensink-FOL} state that
\begin{enumerate*}[label=\emph{(\roman*)}]
\item for every arrow-based condition $c\in \AC R$ there exists a formula $\phi_c$ with $\fv(\phi_c)=X_R$ such that $g\sat c$ iff $v_R;g\sat^\FOL \phi_c$ for any arrow $g\of R\to G$; and

\item for every FOL-formula $\phi$, there is an arrow-based condition $c_\phi$ with $R^{c_\phi}=D_{\fv(\phi)}$ such that $v\sat^\FOL \phi$ iff $v\sat c_\phi$ for any valuation $v\of D_{\fv(\phi)}\to G$.
\end{enumerate*}
The constructions of $\phi_c$ and of $c_\phi$ are given in detail in \cite{Rensink-FOL}.

\iffull
\todo[inline]{The story is currently not complete!}
This means that there is a technical hurdle: the models of a FOL formula are arrows from the discrete graph consisting of its free variables, whereas the models of a nested condition are arrows from their root, which can be an arbitrary graph. To overcome this hurdle, we will introduce the auxiliary notion of a \emph{context} in which a formula is evaluated, essentially consisting of already known facts (reflecting the role of the root object of a condition). In order to define contexts, we first identify a fragment of FOL with a strong relation to graphs.

\begin{itemize}
\item We call a formula $\rho$ \emph{regular} if it equals $\bigwedge_{i\in I} \pi_i$ for some finite set $I$, where for all $i\in I$, $\pi_i$ equals either $x_i=y_i$ or $\la_i(x_i,y_i)$ for some variables $x_i,y_i$ and binary predicate $\la_i$.

\item A regular formula $\rho$ gives rise to an equivalence ${\simeq_\rho}\subseteq \fv(\rho)\times \fv(\rho)$ defined as the smallest equivalence such that $x\simeq_\rho y$ for each conjunct $x=y$ in $\rho$.

\item A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, and an edge $e$ with $s_e=[x]_{\simeq_\rho}$, $\ell_e=\la$ and $t_e=[y]_{\simeq_\rho}$ for each conjunct $\la(x,y)$ in $\rho$.

\item Vice versa, a graph $G=\tupof{X,E}$ gives rise to the regular formula $\rho_G=\bigwedge_{x\in X} x=x \wedge \bigwedge_{e\in E} \ell_e(s_e,t_e)$.

\item Clearly, $\rho$ and $\rho_{G_\rho}$ are equivalent for any regular formula $\rho$.
\end{itemize}



The correspondence of FOL to (arrow-based) conditions hinges on the existence of a \emph{normal form} for FOL formulas.
%
\begin{itemize}
\item For two regular formulas $\rho=\bigwedge_{i\in I} \pi_i$ and $\rho=\bigwedge_{i\in I'} \pi'_i$, we say that $\rho'$ \emph{subsumes} $\rho$, denoted $\rho\sqsubseteq \rho'$, if for all $i\in I$ there is some $i'\in I'$ such that $\pi'_i=\pi'_{i'}$.

\item If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

\item A formula $\phi$ is in \emph{nested normal form} (NNF) if it equals $\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ for some finite index set $J$ (assumed to be of the form $\setof{1,\ldots,|J|}$), where for all $j\in J$:
\begin{itemize}
\item $X_j$ is a finite set of variables,
\item $\rho_j$ is a regular formula, and
\item $\phi_j$ is an NNF formula;
\end{itemize}
such that, moreover, all $X_j$ are disjoint from one another and also from $\fv(\phi)$.
\end{itemize}
%
A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, where $x_i\simeq_\rho y_i$ for each conjunct $x_i=y_i$ in $\rho$, and edges $([x_i]_{\simeq_\rho},\la,[y_i]_{\simeq_\rho})$ for each conjunct $\la(x_i,y_i)$ in $\rho$. If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

To formalise the connection between FOL formulas and nested conditions, we also need the concept of a \emph{context} for a formula $\phi$, which is a regular formula $\gamma$ such that $\fv(\phi)\subseteq \fv(\gamma)$. Clearly, the context of a formula is not fixed.
%
\begin{itemize}
\item An NNF formula $\phi=\bigvee_{j\in J} \exists X_j\st (\rho_j\wedge\neg \phi_j)$ is called \emph{saturated} with respect to a regular formula $\rho$ if $\rho$ is a context for $\phi$, and for all $j\in J$, $\rho\sqsubseteq \rho_j$ and $\phi_j$ is saturated with respect to $\rho_j$.
\end{itemize}
%
If $\rho$ is a regular formula and $\phi=\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ an NNF formula saturated with respect to $\rho$, then the corresponding arrow-based condition is given by
\[ c_{\rho,\phi}=(G_\rho,p_1\ccdots p_{|J|}) \text{ with } p_j=(a_j,c_{\rho_j,\phi_j}) \text{ for all $1\leq j\leq |J|$,}
\]
where $a_j$ is the morphism from $G_\rho$ to $G_{\rho_j}$ induced by $\rho\sqsubseteq \rho_j$.
\fi
