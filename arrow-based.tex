\section{Arrow-based conditions}
\slabel{ab-conditions}

In this section we recall the standard notion of nested condition, using notations that will make the connection with the variation proposed in this paper as straightforward as possible. Here and in the remainder of the paper, we will mostly omit the term ``nested'' and just refer to \emph{conditions}; however, to distinguish between variations upon this theme, we will refer to the standard notion of nested conditions as \emph{arrow-based}.

Along the paper examples and intuitions will be based on $\cat{Graph}$, the category of directed, edge-labelled multigraphs. However, formal definitions and results will be phrased in terms of objects and arrows of a generic category $\bC$ that we assume to be a \emph{presheaf topos}, i.e., a category of contravariant functors from a small category \cat{S} to \cat{Set}, thus \cat{C} $= [\mbox{\cat S}^{\mathrm{op}} \to \cat{Set}]$. Several categories of graphs and hypergraphs are presheaf toposes: for example, directed unlabeled graphs are obtained with \cat{S} the free category generated by $\mygraph{
  \node (1) {$\bullet$};
  \node (2) [right=of 1] {$\bullet$};
  \path (1) edge[bend left=20,->] (2)
        (1) edge[bend right=20,->] (2);
}$. Furthermore, they are closed under the construction of slice and functor categories, thus they include labeled/typed (hyper)graphs (see Sec.~5 of~\cite{AzziCR19}). 

Assuming that \cat{C} is a presheaf topos ensures that all limits and colimits exist and that they can be computed pointwise. Further \cat{C} is \emph{adhesive}~\cite{ls:adhesive-journal}, enjoing several properties exploited in the algebraic theory of graph rewriting, where the results of this paper have potential interesting application.\footnote{Note however that requiring \cat{C} to be just adhesive would not suffice: for example, we need arbitrary pushouts, while adhesivity only guarantees pushouts along monos.}

\medskip
Arrow-based conditions are inductively defined as follows:

\begin{definition}[arrow-based condition]\dlabel{ab-condition}
  Let $R$ be any object of $\bC$. $\AC R$ (the set of \emph{arrow-based conditions} over $R$) and $\AB R$ (the set of \emph{arrow-based branches} over $R$) are the smallest sets such that
  \begin{itemize}
  \item $c\in \AC R$ if $c=(R,p_1\ccdots p_w)$ is a pair with $p_i\in \AB R$ for all $1\leq i\leq w$;
  \item $p\in \AB R$ if $p=(a,c)$ where $a: R\func P$ is an arrow of $\bC$ and $c\in \AC P$.
  \end{itemize}
\end{definition}
%
We regularly abbreviate ``arrow-based" to ``ab". We call $R$ the \emph{root} of an ab-condition or ab-branch, and $P$ the \emph{pattern} of an ab-branch (which is simultaneously the root of its subconditon). \fcite{ab-condition} provides a visualisation of an ab-condition $c$. We use $b,c$ to range over ab-conditions and $p,q$ to range over ab-branches. We use $|c|=w$ to denote the width of an ab-condition $c$, $R^c$ to denote its root, and $p^c_i=(a^c_i,c_i)$ its $i$-th branch. Finally, we use $P^c_i$ ($=R^{c_i}$) for the pattern of branch $p^c_i$. In all these cases, we may omit the superscript $c$ if it is clear from the context.
%
\begin{figure}
  \centering
  \input{figs/ab-condition}
  \caption{Pictorial representation of a arrow-based condition $c$}
  \flabel{ab-condition}
\end{figure}

Note that, as a consequence of the inductive nature of \dcite{ab-condition}, every ab-condition has a finite \emph{depth} $\depth(c)$, defined as $0$ if $|c|=0$ and $1+\max_{1\leq i\leq |c|} \depth(c_i)$ otherwise. The depth will provide a basis for inductive proofs.

\begin{example}\exlabel{ab-conditions}
The following figure depicts two arrow-based conditions. According to the notion of satisfacion introduced below, the first encodes a property over arrows from the empty graph, the second a property over arrows from the discrete one-node graph (meaning essentially that we already know the image of that node). In FOL, the properties can be expressed as follows:
\begin{itemize}
\item $c_1$ encodes $\exists x,y\st \lb(x,y) \wedge \neg \la(y,y)\wedge \neg \exists z\st \lc(y,z)$
\item $c_2$ encodes $\la(x,x)\vee \exists y\st \lb(x,y) \wedge \forall v,z\st \lc(y,v)\wedge \lc(y,z) \rightarrow v=z$
\end{itemize}
Note that in most cases we have used variable names to represent nodes, to make the connection to the corresponding FOL properties more immediately understandable. The actual arrows are in all cases implied by the graph structure and variable names.
\begin{center}
\input{figs/ex-ab-conditions}
\end{center}
\end{example}

\subsection{Satisfaction}

A condition expresses a property of arrows from its root to an arbitrary object. This is operationalised through the notion of \emph{satisfaction}.

\begin{definition}[satisfaction of arrow-based conditions]\dlabel{ab-satisfaction}
  Let $c$ be an ab-condition over $R$ and $g:R\func G$ an arrow from $c$'s root to some object $G$. We say that \emph{$g$ satisfies $c$}, denoted $g\sat c$, if there is a branch $p_i=(a_i,c_i)$ of $c$ and an arrow $h:P_i\func G$ such that
  \begin{itemize}
  \item $g=a_i;h$
  \item $h\nsat c_i$.
  \end{itemize}
\end{definition}
%
%\emph{Terminology and notation.}
If $g\sat c$, we also say that $g$ is a \emph{model} for $c$. We call $p_i$ the \emph{responsible branch} and $h$ the \emph{witness} for $g\sat c$. Pictorially, $g\sat c$ with responsible branch $p_i$ and witness $h$ can be visualised as in \fcite{ab-satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/ab-satisfaction}
  \caption{Pictorial representation of $g\sat c$, with responsible branch $p_i=(a_i,c_i)$ and witness $h$}
  \flabel{ab-satisfaction}
\end{figure}

Based on the notion of satisfaction, we also define \emph{semantic entailment} $b\entails c$ and \emph{semantic equivalence} $b\equiv c$ over conditions (over the same root):
%
\begin{align*}
b \entails c & \text{ if for all arrows $g$: } g\sat b \text{ implies } g\sat c \\
b \equiv c & \text{ if for all arrows $g$: } g\sat b \text{ if and only if } g\sat c 
\end{align*}
%
\begin{example}\exlabel{ab-satisfaction}
For the ab-conditions in \excite{ab-conditions}, the following morphisms can be considered as models:
\begin{itemize}
\item Let $G_1=\mygraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\lc} (1);
	  }$
and let $g$ be the only arrow from the empty graph to $G_1$. This is a model of $c_1$: the witness $h$ (for the first level) maps $x$ to the left-hand node and $y$ to the right-hand node. $h$ does not satisfy the subcondition because it cannot be extended with either the $\la$-loop specified by the left branch or the outgoing $\lc$-edge specified by the right branch.
	  
\item Let $G_2=\mygraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\node (3) [right=of 2] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\la} (1)
      (2) edge[->] node[above] {\lc} (3);
	  }$
and let $g$ be the only arrow from the empty graph to $G_2$. This is \emph{not} a model of $c_1$: there are two candidate witnesses, but both satisfy one of the branches of the subcondition.

\item Let $G_1$ be as above and consider the arrow $g$ from the one-node discrete graph that maps that node to $G_1$'s left-hand node. This is a model of $c_2$, with the obvious witness.
\end{itemize}
\end{example}

\subsection{Instantiating the framework}

In the literature\todo{AC: this subsection can be deleted}, arrow-based conditions have been studied for different base categories. The examples we have shown up to now were all based on $\Graph$, the category of edge-labelled, multi-sorted graphs. This is exemplary of any adhesive category: for instance, one might alternatively consider hypergraphs. Another interesting candidate is $\Cospan[\Graph]$, the category where objects are graphs and arrows are cospans of graph morphisms --- which in turn can be generalised to $\Cospan[\cat C]$ for any adhesive category $\cat C$.

\subsection{Connection to first-order logic}

It has been shown (e.g., \cite{Rensink-FOL,Habel-FOL}) that every first-order logic (FOL) formula can be encoded as an arrow-based nested condition over $\Graph$. For the sake of completeness, we summarise the construction here. We restrict to binary predicates, which we take from the set of edge labels $\Lab$.

The syntax of FOL that we will use in the following is given by the grammar
%
\[ \phi \:::=\: \True
        \:\mid\: \False
		\:\mid\: \la(x_1,x_2)
        \:\mid\: x_1=x_2
		\:\mid\: \phi_1\wedge \phi_2
		\:\mid\: \phi_1\vee \phi_2
		\:\mid\: \neg\phi_1
		\:\mid\: \exists \bar x\st \phi_1 
		\]
where the $x_i$ are variables (say from some set $X$), $\bar x\in X^*$ is a finite sequence of variables and $\la$ is a binary predicate. We also use the concept of \emph{free variables} of $\phi$, denoted $\fv(\phi)$, inductively defined in the usual way.

As for conditions, the semantics of FOL is defined through a notion of satisfaction; however, the models are not arbitrary arrows in $\Graph$ but \emph{valuations} that map the free variables to the nodes of a graph. Such a valuation can be seen as an arrow from the discrete graph with node set $X$, which for the purpose of this discussion we will denote $D_X$. Hence, the models of a formula $\phi$ are arrows $v:D_X\to G$ (for some graph $G$) such that $v\sat\phi$.

This means that there is a technical hurdle: the models of a FOL formula are arrows from the discrete graph consisting of its free variables, whereas the models of a nested condition are arrows from their root, which can be an arbitrary graph. To overcome this hurdle, we will introduce the auxiliary notion of a \emph{context} in which a formula is evaluated, essentially consisting of already known facts (reflecting the role of the root object of a condition). In order to define contexts, we first identify a fragment of FOL with a strong relation to graphs.

\begin{itemize}
\item We call a formula $\rho$ \emph{regular} if it equals $\bigwedge_{i\in I} \pi_i$ for some finite set $I$, where for all $i\in I$, $\pi_i$ equals either $x_i=y_i$ or $\la_i(x_i,y_i)$ for some variables $x_i,y_i$ and binary predicate $\la_i$.

\item A regular formula $\rho$ gives rise to an equivalence ${\simeq_\rho}\subseteq \fv(\rho)\times \fv(\rho)$ defined as the smallest equivalence such that $x\simeq_\rho y$ for each conjunct $x=y$ in $\rho$.

\item A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, and an edge $e$ with $s_e=[x]_{\simeq_\rho}$, $\ell_e=\la$ and $t_e=[y]_{\simeq_\rho}$ for each conjunct $\la(x,y)$ in $\rho$.

\item Vice versa, a graph $G=\tupof{X,E}$ gives rise to the regular formula $\rho_G=\bigwedge_{x\in X} x=x \wedge \bigwedge_{e\in E} \ell_e(s_e,t_e)$.

\item Clearly, $\rho$ and $\rho_{G_\rho}$ are equivalent for any regular formula $\rho$.
\end{itemize}



The correspondence of FOL to (arrow-based) conditions hinges on the existence of a \emph{normal form} for FOL formulas.
%
\begin{itemize}
\item For two regular formulas $\rho=\bigwedge_{i\in I} \pi_i$ and $\rho=\bigwedge_{i\in I'} \pi'_i$, we say that $\rho'$ \emph{subsumes} $\rho$, denoted $\rho\sqsubseteq \rho'$, if for all $i\in I$ there is some $i'\in I'$ such that $\pi'_i=\pi'_{i'}$.

\item If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

\item A formula $\phi$ is in \emph{nested normal form} (NNF) if it equals $\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ for some finite index set $J$ (assumed to be of the form $\setof{1,\ldots,|J|}$), where for all $j\in J$:
\begin{itemize}
\item $X_j$ is a finite set of variables,
\item $\rho_j$ is a regular formula, and
\item $\phi_j$ is an NNF formula;
\end{itemize}
such that, moreover, all $X_j$ are disjoint from one another and also from $\fv(\phi)$.
\end{itemize}
%
A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, where $x_i\simeq_\rho y_i$ for each conjunct $x_i=y_i$ in $\rho$, and edges $([x_i]_{\simeq_\rho},\la,[y_i]_{\simeq_\rho})$ for each conjunct $\la(x_i,y_i)$ in $\rho$. If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

To formalise the connection between FOL formulas and nested conditions, we also need the concept of a \emph{context} for a formula $\phi$, which is a regular formula $\gamma$ such that $\fv(\phi)\subseteq \fv(\gamma)$. Clearly, the context of a formula is not fixed.
%
\begin{itemize}
\item An NNF formula $\phi=\bigvee_{j\in J} \exists X_j\st (\rho_j\wedge\neg \phi_j)$ is called \emph{saturated} with respect to a regular formula $\rho$ if $\rho$ is a context for $\phi$, and for all $j\in J$, $\rho\sqsubseteq \rho_j$ and $\phi_j$ is saturated with respect to $\rho_j$.
\end{itemize}
%
If $\rho$ is a regular formula and $\phi=\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ an NNF formula saturated with respect to $\rho$, then the corresponding arrow-based condition is given by
\[ c_{\rho,\phi}=(G_\rho,p_1\ccdots p_{|J|}) \text{ with } p_j=(a_j,c_{\rho_j,\phi_j}) \text{ for all $1\leq j\leq |J|$,}
\]
where $a_j$ is the morphism from $G_\rho$ to $G_{\rho_j}$ induced by $\rho\sqsubseteq \rho_j$.
