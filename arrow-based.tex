\section{Arrow-based conditions}
\slabel{ab-conditions}

In this section we recall the standard notion of nested condition, using notations that will make the connection with the variation proposed in this paper as straightforward as possible. Here and in the remainder of the paper, we will mostly omit the term ``nested'' and just refer to \emph{conditions}; however, to distinguish between variations upon this theme, we will refer to the standard notion of nested conditions as \emph{arrow-based}.

Along the paper examples and intuitions will be based on $\cat{Graph}$, the category of directed, edge-labelled multigraphs. However, formal definitions and results will be phrased in terms of objects and arrows of a generic category $\bC$ that we assume to be a \emph{presheaf topos}, i.e., a category of contravariant functors from a small category \cat{S} to \cat{Set}, thus \cat{C} $= [\mbox{\cat S}^{\mathrm{op}} \to \cat{Set}]$. Several categories of graphs and hypergraphs are presheaf toposes: for example, directed unlabeled graphs are obtained with \cat{S} the free category generated by $\mygraph{
  \node (1) {$\bullet$};
  \node (2) [right=of 1] {$\bullet$};
  \path (1) edge[bend left=20,->] (2)
        (1) edge[bend right=20,->] (2);
}$. Furthermore, they are closed under the construction of slice and functor categories, thus they include labeled/typed (hyper)graphs (see Sec.~5 of~\cite{AzziCR19}). 

Assuming that \cat{C} is a presheaf topos ensures that all limits and colimits exist and that they can be computed pointwise. Furthermore, \cat{C} is \emph{adhesive}~\cite{ls:adhesive-journal}, enjoing several properties exploited in the algebraic theory of graph rewriting, where the results of this paper have potential interesting application.\footnote{Note however that requiring \cat{C} to be just adhesive would not suffice: for example, we need arbitrary pushouts, while adhesivity only guarantees pushouts along monos.}

\medskip\noindent
Arrow-based conditions are inductively defined as follows:

\begin{definition}[arrow-based condition]\dlabel{ab-condition}
  Let $R$ be any object of $\bC$. $\AC R$ (the set of \emph{arrow-based conditions} over $R$) and $\AB R$ (the set of \emph{arrow-based branches} over $R$) are the smallest sets such that
  \begin{itemize}
  \item $c\in \AC R$ if $c=(R,p_1\ccdots p_w)$ is a pair with $p_i\in \AB R$ for all $1\leq i\leq w$;
  \item $p\in \AB R$ if $p=(a,c)$ where $a: R\to P$ is an arrow of $\bC$ and $c\in \AC P$.
  \end{itemize}
\end{definition}
%
We regularly abbreviate ``arrow-based" to ``ab". We call $R$ the \emph{root} of an ab-condition or ab-branch, and $P$ the \emph{pattern} of an ab-branch (which is simultaneously the root of its subconditon). \fcite{ab-condition} provides a visualisation of an ab-condition $c$. We use $b,c$ to range over ab-conditions and $p,q$ to range over ab-branches. We use $|c|=w$ to denote the width of an ab-condition $c$, $R^c$ to denote its root, and $p^c_i=(a^c_i,c_i)$ its $i$-th branch. Finally, we use $P^c_i$ ($=R^{c_i}$) for the pattern of branch $p^c_i$. In all these cases, we may omit the superscript $c$ if it is clear from the context.
%
\begin{figure}[t]
\centering
\subcaptionbox
  {Condition $c=(R,p_1\ccdots p_w)$, with $p_i=(a_i,c_i)$ for $1\leq i\leq w$
   \flabel{ab-condition}}
  [.45\textwidth]
  {\input{figs/ab-condition}}
\quad
\subcaptionbox
  {$g\sat c$, with responsible branch $p_i=(a_i,c_i)$ and witness $h$ such that $g=a_i;h$
   \flabel{ab-satisfaction}}
  [.5\textwidth]
  {\input{figs/ab-satisfaction}}
\caption{Visualisations for arrow-based conditions}
\end{figure}

Note that, as a consequence of the inductive nature of \dcite{ab-condition}, every ab-condition has a finite \emph{depth} $\depth(c)$, defined as $0$ if $|c|=0$ and $1+\max_{1\leq i\leq |c|} \depth(c_i)$ otherwise. The depth will provide a basis for inductive proofs.

\begin{example}\exlabel{ab-conditions}
\fcite{ab-conditions} depicts three arrow-based conditions, rooted in the discrete one-node graph \inline{\onenode x}. According
to the notion of satisfacion introduced below, assuming that we already know the image of $x$ in a graph, the properties can be expressed as follows in FOL:
\begin{itemize}
\item $c_1$ encodes $\exists y\st \lb(x,y) \wedge \neg \la(y,y)\wedge \neg \exists z\st \lc(y,z)$ 
\item $c_2$ encodes $\la(x,x)\vee (\exists y\st \lb(x,y) \wedge \forall v,z\st \lc(y,v)\wedge \lc(y,z) \rightarrow v=z)$
\item $c_3$ encodes $\lb(x,x)\wedge \nexists y\st(\la(x,y)\vee \lc(x,y))$
\end{itemize}
\begin{figure}[t]
\begin{center}
\input{figs/ex-ab-conditions}
\end{center}
\caption{Examples of arrow-based conditions (see \excite{ab-conditions})}
\flabel{ab-conditions}
\end{figure}
Note that we have used variable names to represent nodes, to make the connection to the corresponding FOL properties more immediately understandable. The arrows are in all cases implied by the graph structure and variable names.
\end{example}

\subsection{Satisfaction}

A condition expresses a property of arrows from its root to an arbitrary object. This is operationalised through the notion of \emph{satisfaction}.

\begin{definition}[satisfaction of arrow-based conditions]\dlabel{ab-satisfaction}
  Let $c$ be an ab-condition over $R$ and $g:R\to G$ an arrow from $c$'s root to some object $G$. We say that \emph{$g$ satisfies $c$}, denoted $g\sat c$, if there is a branch $p_i=(a_i,c_i)$ of $c$ and an arrow $h:P_i\to G$ such that
  \begin{enumerate*}
  \item $g=a_i;h$ and
  \item $h\nsat c_i$.
  \end{enumerate*}
\end{definition}
%
If $g\sat c$, we also say that $g$ is a \emph{model} for $c$. We call $p_i$ the \emph{responsible branch} and $h$ the \emph{witness} for $g\sat c$. Pictorially, $g\sat c$ with responsible branch $p_i$ and witness $h$ can be visualised as in \fcite{ab-satisfaction}.

\todo{AR: does this come too early? In \excite{ab-satisfaction} we can observe that $c_3\entails c_2\entails c_1$, but otherwise this is only used in \pcite{ab-morphisms preserve models}, which is 5 pages down the line.\\ AC: No, it is fine to keep it here. I would add this to the example.} Based on the notion of satisfaction, we also define \emph{semantic entailment} $b\entails c$ and \emph{semantic equivalence} $b\equiv c$ over conditions (over the same root):
%
\begin{align*}
b \entails c & \text{ if for all arrows $g$: } g\sat b \text{ implies } g\sat c \\
b \equiv c & \text{ if for all arrows $g$: } g\sat b \text{ if and only if } g\sat c 
\end{align*}

\begin{example}\exlabel{ab-satisfaction}
Let us consider some models for the ab-conditions in \fcite{ab-conditions}.
\begin{itemize}
\item Let $G_1=\myinlinegraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\lc} (1);
}$
and let $g$ be the arrow from the one-node discrete graph \inline{\onenode x} to the left-hand node of $G_1$. It follows that $g\sat c_1$: the witness $h$ (for $c_{11}$) maps $y$ to the right-hand node of $G_1$. $h$ does not satisfy the subconditions of $c_{11}$ because it cannot be extended with either the $\la$-loop specified by $c_{111}$ or the outgoing $\lc$-edge specified by $c_{112}$. Similarly, $g\sat c_2$, but on the other hand $g\nsat c_3$ because there is no witness for $c_{31}$ ($G_1$ does not have the required $\lb$-loop).

\item Let $G_2=\myinlinegraph{
\node (1) {$\bullet$};
\node (2) [right=of 1] {$\bullet$};
\node (3) [right=of 2] {$\bullet$};
\path (1) edge[bend left=20,->] node[near start,above] {\lb} (2)
      (2) edge[bend left=20,->] node[near start,below] {\lb} (1)
	  (1) edge[loop left,->] node[left] {\la} (1)
      (2) edge[->] node[above] {\lc} (3);
	  }$
and let $g,g',g''$ be the three arrows from \inline{\onenode x} to $G_2$. We have $g\nsat c_1$, $g'\nsat c_1$ and $g''\nsat c_1$: the first two have witnesses for $c_{11}$ but are ruled out by either $c_{11}$ (in the case of $g$) or $c_{12}$ (in the case of $g'$), whereas the third does not even have a witness for $c_{11}$. Instead, both $g\sat c_2$ (in fact there are two distinct witnesses, one for $c_{21}$ and one for $c_{22}$) and $g'\sat c_2$ (due to $c_{22}$), but again $g''\nsat c_2$. None of the models satisfy $c_3$.

\item If $G_3=\inline{\oneloopleft \bullet b}$, then the only arrow $g$ from \inline{\onenode x} to $G_3$ has $g\sat c_1$, $g\sat c_2$ and $g\sat c_3$. In general, it can be checked that every model of $c_3$ is also a model of $c_2$ and a model of $c_1$, thus $c_3 \entails c_2$ and $c_3 \entails c_1$. Instead, for example, $c_2 \nsat c_1$ as shown by morphism $g$ of the previous point. 
\end{itemize}
\end{example}

\subsection{Connection to first-order logic}

It has been shown (e.g., \cite{Rensink-FOL,Habel-FOL}) that every first-order logic (FOL) formula can be encoded as an arrow-based nested condition over $\Graph$. For the sake of completeness, we summarise the construction here.\todo{AC: not if not full: add precise reference} We restrict to binary predicates, which we take from the set of edge labels $\Lab$.

The syntax of FOL that we will use in the following is given by the grammar
%
\[ \phi \:::=\: \True
        \:\mid\: \False
		\:\mid\: \la(x_1,x_2)
        \:\mid\: x_1=x_2
		\:\mid\: \phi_1\wedge \phi_2
		\:\mid\: \phi_1\vee \phi_2
		\:\mid\: \neg\phi_1
		\:\mid\: \exists \bar x\st \phi_1 
		\]
where the $x_i$ are variables (say from some set $X$), $\bar x\in X^*$ is a finite sequence of variables and $\la$ is a binary predicate. We also use the concept of \emph{free variables} of $\phi$, denoted $\fv(\phi)$, inductively defined in the usual way.\todo{Formulate the connection between FOL and ab-conditions}

\iffull
As for conditions, the semantics of FOL is defined through a notion of satisfaction; however, the models are not arbitrary arrows in $\Graph$ but \emph{valuations} that map the free variables to the nodes of a graph. Such a valuation can be seen as an arrow from the discrete graph with node set $X$, which for the purpose of this discussion we will denote $D_X$. Hence, the models of a formula $\phi$ are arrows $v:D_X\to G$ (for some graph $G$) such that $v\sat\phi$.

This means that there is a technical hurdle: the models of a FOL formula are arrows from the discrete graph consisting of its free variables, whereas the models of a nested condition are arrows from their root, which can be an arbitrary graph. To overcome this hurdle, we will introduce the auxiliary notion of a \emph{context} in which a formula is evaluated, essentially consisting of already known facts (reflecting the role of the root object of a condition). In order to define contexts, we first identify a fragment of FOL with a strong relation to graphs.

\begin{itemize}
\item We call a formula $\rho$ \emph{regular} if it equals $\bigwedge_{i\in I} \pi_i$ for some finite set $I$, where for all $i\in I$, $\pi_i$ equals either $x_i=y_i$ or $\la_i(x_i,y_i)$ for some variables $x_i,y_i$ and binary predicate $\la_i$.

\item A regular formula $\rho$ gives rise to an equivalence ${\simeq_\rho}\subseteq \fv(\rho)\times \fv(\rho)$ defined as the smallest equivalence such that $x\simeq_\rho y$ for each conjunct $x=y$ in $\rho$.

\item A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, and an edge $e$ with $s_e=[x]_{\simeq_\rho}$, $\ell_e=\la$ and $t_e=[y]_{\simeq_\rho}$ for each conjunct $\la(x,y)$ in $\rho$.

\item Vice versa, a graph $G=\tupof{X,E}$ gives rise to the regular formula $\rho_G=\bigwedge_{x\in X} x=x \wedge \bigwedge_{e\in E} \ell_e(s_e,t_e)$.

\item Clearly, $\rho$ and $\rho_{G_\rho}$ are equivalent for any regular formula $\rho$.
\end{itemize}



The correspondence of FOL to (arrow-based) conditions hinges on the existence of a \emph{normal form} for FOL formulas.
%
\begin{itemize}
\item For two regular formulas $\rho=\bigwedge_{i\in I} \pi_i$ and $\rho=\bigwedge_{i\in I'} \pi'_i$, we say that $\rho'$ \emph{subsumes} $\rho$, denoted $\rho\sqsubseteq \rho'$, if for all $i\in I$ there is some $i'\in I'$ such that $\pi'_i=\pi'_{i'}$.

\item If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

\item A formula $\phi$ is in \emph{nested normal form} (NNF) if it equals $\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ for some finite index set $J$ (assumed to be of the form $\setof{1,\ldots,|J|}$), where for all $j\in J$:
\begin{itemize}
\item $X_j$ is a finite set of variables,
\item $\rho_j$ is a regular formula, and
\item $\phi_j$ is an NNF formula;
\end{itemize}
such that, moreover, all $X_j$ are disjoint from one another and also from $\fv(\phi)$.
\end{itemize}
%
A regular formula $\rho$ can be encoded as a graph $G_\rho$ with node set $[\fv(\rho)]/{\simeq_\rho}$, where $x_i\simeq_\rho y_i$ for each conjunct $x_i=y_i$ in $\rho$, and edges $([x_i]_{\simeq_\rho},\la,[y_i]_{\simeq_\rho})$ for each conjunct $\la(x_i,y_i)$ in $\rho$. If $\rho'$ subsumes $\rho$, there is an obvious graph morphism from $G_\rho$ to $G_{\rho'}$ with node mapping $[x]_{\simeq_\rho}\mapsto [x]_{\simeq_{\rho'}}$, which is well-defined because ${\simeq_\rho}\subseteq {\simeq_{\rho'}}$.

To formalise the connection between FOL formulas and nested conditions, we also need the concept of a \emph{context} for a formula $\phi$, which is a regular formula $\gamma$ such that $\fv(\phi)\subseteq \fv(\gamma)$. Clearly, the context of a formula is not fixed.
%
\begin{itemize}
\item An NNF formula $\phi=\bigvee_{j\in J} \exists X_j\st (\rho_j\wedge\neg \phi_j)$ is called \emph{saturated} with respect to a regular formula $\rho$ if $\rho$ is a context for $\phi$, and for all $j\in J$, $\rho\sqsubseteq \rho_j$ and $\phi_j$ is saturated with respect to $\rho_j$.
\end{itemize}
%
If $\rho$ is a regular formula and $\phi=\bigvee_{j\in J} \exists X_j\st \rho_j\wedge\neg \phi_j$ an NNF formula saturated with respect to $\rho$, then the corresponding arrow-based condition is given by
\[ c_{\rho,\phi}=(G_\rho,p_1\ccdots p_{|J|}) \text{ with } p_j=(a_j,c_{\rho_j,\phi_j}) \text{ for all $1\leq j\leq |J|$,}
\]
where $a_j$ is the morphism from $G_\rho$ to $G_{\rho_j}$ induced by $\rho\sqsubseteq \rho_j$.
\fi
