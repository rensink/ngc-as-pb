\section{Introduction}

Representing formulas of First-Order Logic (FOL) by graphs or more general graphical structures was explored in various areas of Theoretical Computer Science and Logics along the decades. A canonical example is represented by edge-labelled graphs, which can be regarded as an alternative syntax for formulas of a fragment of FOL including just basic (binary) predicates, equality, conjunction and existential quantification: we call this briefly the $\exists$-fragment.

Let $\Lab = \{\gl{a}, \gl{b}, \gl{c}, \ldots\}$ be a set of binary relation symbols, which we shall use also as edge labels. As an example, let $A$ be the graph $\inline{\twoedge{x}{a}{y}{b}{z}}$. We consider it as a sound representation of the formula  $\phi_A = \exists x,y,z\st \gl{a}(x,y) \wedge \gl{b}(y,x)$, in the following sense: a graph $G$ satisfies $\phi_A$ (or is a \emph{model} of $\phi_A$) if and only if there is a graph morphism $h$ from $A$ to $G$. 
Now consider $B = \inline{\oneedge{x}{a}{y}}$, representing formula $\phi_{B} = \exists x,y\st \gl{a}(x,y)$. Graph $B$ has an obvious inclusion morphism into $A$, viz.\ $i\of B \to A$. Therefore every morphism $h\of A \to G$ gives rise to a composed morphism $i;h\of B\to G$, implying that every graph that satisfies $\phi_A$ also satisfies $\phi_{B}$, thus $\phi_A$ \emph{entails} $\phi_{B}$ (written $\phi_A \entails \phi_{B}$). It is worth noting that, in this elementary framework, graph morphisms can represent both a satisfaction relation (between formulas and models) and an entailment relation among formulas.

These concepts were exploited for example by Chandra and Merlin in \cite{DBLP:conf/stoc/ChandraM77} in the framework of relational database queries. They show there that every \emph{conjunctive query} (a formula of the $\exists$-fragment, but with relations of any arity) has a natural model, a graph, and query inclusion is equivalent to the existence of a graph homomorphism between those natural models. Therefore morphisms are not only sound, but also complete with respect to entailment, and it follows that query inclusion is decidable, even if NP-complete: an interesting logical result obtained with graph theoretical techniques.   


In the realm of Graph Transformation Systems  (GTSs)~\cite{eept:fundamentals-agt,DBLP:books/sp/HeckelT20}
% (e.g.~in the Double-Pushout Approach~\cite{eps:gragra-algebraic})
 the need of representing formulas by graphs arose in a natural way. Indeed,
in any approach a rule consists of at least two graphs, $L \leadsto R$, and to apply it to a graph $G$, first a morphism $m: L \to G$ has to be found. 
 By the above discussion, we can consider $L$ as a formula of the $\exists$-fragment that has to be satisfied by $G$, as an application condition of the rule. 

It soon turned out that in order to use GTSs for even simple specifications, more expressive application conditions were needed. 
In~\cite{NegativeAC} the authors introduced \emph{Negative Application Conditions (NACs)}, allowing to express (to some extent) negation and disjunction.  A NAC $\cN$ is  a finite set of morphisms from $L$, $\cN = \{n_i: L \to Q_i\}_{i\in[1,k]}$, and a morphism $m: L \to G$ \emph{satisfies} $\cN$ if for all $i\in[1,k]$ there is no morphism $m_i: Q_i \to G$ such that $n_i;m_i = m$. 
It follows that such a NAC represents a formula of the shape $\exists \bar{x}\st \phi_L \wedge \neg (\exists \bar{y}_1\st Q_1 \vee \ldots \vee \exists \bar{y}_n\st Q_n)$: as in \cite{Rensink-FOL}, we call this the $\exists \neg \exists$-fragment (of FOL).

Note that differently from the $\exists$-fragment, 
%existential-conjunctive framework, 
a formula of the $\exists \neg \exists$-fragment is no longer a graph, but a diagram (a ``star'') in \cat{Graph}, the category of graphs; and satisfaction does not require just the existence of a matching morphism from $L$, but also the non-existence of certain other morphisms.
%
NACs were generalized in~\cite{Rensink-FOL,Habel-FOL} to \emph{Nested (Application) Conditions}, where the structure of a condition is a finite tree of arbitrary depth rooted at $L$, and satisfaction is defined like for NACs, but iterating further at each level of the tree. Interestingly, Nested Conditions were proved to have the same expressive power of full FOL.

Since application conditions denote formulas, they are the objects of an obvious category (actually, a preorder) where arrows represent entailment. But differently from the case of the $\exists$-fragment, where entailment can be witnessed by the existence of a graph morphism, we are not aware of similar results for the larger $\exists \neg\exists$-fragment or for FOL. More explicitly, despite the fact that NACs first and Nested Conditions next were defined as suitable diagrams in a category of graphs (or of other structures), we are not aware of any definition of \emph{structural morphisms} among such application conditions, to represent (some cases of) entailment like simple graph morphisms do for the $\exists$-fragment. In this paper we address exactly this issue, one main challenge being to ensure that a morphism exists between two conditions only if they are related by entailment.

We start by recalling in \scite{ab-conditions} the main definitions related to Nested Conditions from \cite{Rensink-FOL}. We call such conditions \emph{arrow-based}.
%, to distinguish them from the \emph{span-based} ones introduced later. 
In \scite{ab-morphisms} we present the original definition of morphism among such conditions, which come in two variants giving rise to two categories of conditions. Soundness of morphisms w.r.t.~entailment is ensured by the existence of functors to the category of conditions and entailment. 

Even if completeness of such morphisms in the sense of \cite{DBLP:conf/stoc/ChandraM77} cannot hold due to undecidability of entailment in FOL, the lack of morphisms between entailment-related conditions even in very simple cases leads us to introduce, in \scite{sb-conditions}, a variant of conditions called \emph{span-based}, for which we define in turn a few notions of morphisms, and show that they give rise to categories into which those of arrow-based conditions embed.
In \scite{conclusion} we summarize the contributions of the paper, discuss some related work and hint at future developments. Full proofs of most of the statements and a few auxliary results are collected in the \acite{proofs}.


 