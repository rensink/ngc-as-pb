\section{Morphisms of arrow-based conditions}

The notion of \emph{morphism} of nested conditions has not received much attention in the literature. When considered at all, such as in \cite{bchk:conditional-reactive-systems,sksclo:coinductive-techniques-for-satisfiability}, they are essentially based on the semantics in terms of satisfaction. Indeed, entailment establishes a preorder over conditions. Let us denote the resulting category $\ABC^{\entails}$.

The question that we address in this section is to establish a meaningful \emph{structural} notion of condition morphism. That is, given the fact that an ab-condition is essentially a diagram in the category $\bC$, a structural morphism from $b$ to $c$ consists of arrows between objects of $b$ and objects of $c$ satisfying certain commutativity conditions. For morphisms to be meaningful, they should certainly only exist where there is entailment; in other words, we require there to be a functor to $\ABC^{\entails}$. As we will see, this requirement implies that it is not enough to consider only arrows from objects of $b$ \emph{to} objects of $c$, since in our definition of satisfaction, the direction of entailment flips at every subsequent nesting level. We also observe that the existence of a functor to $\ABC^{\entails}$ means that we only consider morphisms between conditions with the same root.

The underlying principle for a morphism $m$ from $b=(R,p^b_1\ccdots p^c_{|b|})$ to $c=(R,p^c_1\ccdots p^c_{|c|})$ is that it must identify, for every $b$-branch $p^b_i$, a $c$-branch $p^c_j$ that entails it. Entailment of branches, in turn, is captured by the existence of an arrow $v_i$ from $P^c_j$ to $P^b_i$ (hence going in the \emph{opposite} direction of $m$) such that there is (recursively, but in the opposite direction) a morphism between the subconditions $c_j$ and $b_i$; however, this sub-morphism can only exist ``modulo" the morphism $v_i$ between their roots. The main task of the next subsection is to make the concept of ``modulo $v_i$" precise.

\subsection{Root shifting}

In order to relate conditions at different roots, we introduce a special kind of mapping called a \emph{root shifter}, which will later turn out to be functors between categories of conditions. For now, we note that the purpose of root shifters is to relate the models of a condition $b$ to those of a condition $c$, given an arrow $v:R^b\to R^c$ between their roots (the existence of which implies that the model sets are typically disjoint). To be more precise, we will require that \emph{every $v$-prepended model of $b$ induces a model for $c$}: that is, if $v;g$ is a model of $b$, then $g$ is a model of $c$.

This can be achieved in essentially two ways, on the basis of $v$: by constructing $c$ from $b$ (which we will call \emph{forward shifting}) or by constructing $b$ from $c$ (which we will call \emph{backward shifting}).

We will first define the notion of shifting for arrows (where it is called source shifting) and then extend this in a natural way to conditions (where it is called root shifting).

\begin{definition}[source shifter]\dlabel{ab-source shifter}
Let $X,Y$ be objects. and $v:A\to B$ an arrow.
\begin{itemize}[topsep=\smallskipamount]
\item A \emph{source shifter} $\cS$ from $X$ to $Y$ is a function from $X$-sourced arrows to $Y$-sourced ones, such that for all arrows $a:X\to Y, t:Y\to Z$:
%
\begin{equation}\eqlabel{shifters are functors}
\cS(a;t) = \cS(a);t \enspace.
\end{equation}
%
\item A \emph{forward source shifter $\cS$ for $v$} is a source shifter from $A$ to $B$ such that for all $a:A\to C$, $g:B\to G$ and $h:C\to G$:
%
\begin{equation}\eqlabel{forward condition}
v;g = a;h \text{ implies } g = \cS(a);h \enspace.
\end{equation}
%
\item A \emph{backward source shifter $\cS$ for $v$} is a source shifter from $B$ to $A$ such that for all $a:B\to C$, $g:B\to G$ and $h:C\to G$:
%
\begin{equation}\eqlabel{backward condition}
v;g = \cS(a);h \text{ implies } g = a;h \enspace.
\end{equation}
\end{itemize}
\end{definition}
%
If $\cS$ is known to be a forward shifter, we often use $\cF$ to denote it; similarly, we often use $\cB$ to denote backward shifters. Condition \eqref{eq:shifters are functors} is actually quite strong, since it holds for any arrow $a$ and $t$; in particular also for the case that $a=\id_X$ (and hence $Y=X$). This leads to the following observation.
%
\begin{lemma}\llabel{ab-source shifters}
Let $\cS$ map $X$-sourced arrows to $Y$-sourced arrows. The following statements are equivalent.
\begin{enumerate}[topsep=\smallskipamount,label=(\alph*),ref=(\alph{enumi})]
\item\label{shifter-1} There exists a $v:Y\to X$ such that $\cS(a)=v;a$ for all $a:X\to Z$;
\item\label{shifter-2} $\cS$ is a source shifter from $X$ to $Y$ such that $\cS(\id_X)=v$.
\end{enumerate}
\end{lemma}

\begin{proof}~
\begin{itemize}[topsep=\smallskipamount]
\item \emph{\ref{shifter-1} implies \ref{shifter-2}.}
%
Assume that \ref{shifter-1} holds. To show that  $\cS$ is a source shifter, note that  \eqcite{shifters are functors} holds by $\cS(a;t)=v;a;t=\cS(a);t$. Furthermore, $\cS(\id_X)=v;\id_X=v$.

\item \emph{\ref{shifter-2} implies \ref{shifter-1}.}
%
Assume that \ref{shifter-2} holds. Let $a:X\to Z$; by \eqref{eq:shifters are functors}, it follows that $\cS(a)=\cS(\id_X;a)=\cS(\id_X);a=v;a$.\qed
\end{itemize}
\end{proof}
%
Knowing that source shifters from $X$ are entirely determined by $\cS(\id_X)$ gives us a basis for their construction. The following proposition characterises the (forward and backward) root shifters that exist in general.
%
\begin{proposition}[known source shifters]\plabel{ab-source shifters}
Let $v:A\to B$ be an arrow.
\begin{enumerate}[topsep=\smallskipamount]
\item The following three statements are equivalent.
\begin{enumerate}[label=(\alph*),ref=\theenumi(\theenumii)]
\item\label{forward-1} $\cS$ is a forward source shifter for $v$;
\item\label{forward-2} $\cS$ is a source shifter from $A$ to $B$ such that $\cS(v)=\id_B$;
\item\label{forward-3} $\cS$ is a mapping from $A$-sourced arrows to $B$-sourced arrows such that $s=\cS(\id_A)$ is a section of $v$ and $\cS(a)=s;a$ for all $a:A\to C$.
\end{enumerate}
\item If $\cS$ is a source shifter such that $\cS(\id_B)=v$, then $\cS$ is a backward source shifter for $v$ if and only if $v$ is epi.
\end{enumerate}
\end{proposition}
%
\begin{proof}~
\begin{enumerate}[topsep=\smallskipamount]
\item
We show $\ref{forward-1} \Rightarrow \ref{forward-2} \Rightarrow \ref{forward-3} \Rightarrow \ref{forward-1}$.
\begin{itemize}
\item \emph{\ref{forward-1} implies \ref{forward-2}.}
%
Assume that \ref{forward-1} holds. By definition, $\cS$ is a source shifter from $A$ to $B$. Now consider \eqref{eq:forward condition} with $a=v$ and $g=h=\id_B$: then $v;g=a;h$, hence $\id_B=g = \cS(a);h=\cS(a)$.

\item \emph{\ref{forward-2} implies \ref{forward-3}.}
%
Assume that \ref{forward-2} holds. By definition, $\cS$ is a mapping from $A$-sourced arrows to $B$-sourced arrows; moreover, if $s=\cS(\id_A)$ then $s;v=\cS(\id_A);v=\cS(\id_A;v)=\cS(v)=\id_B$, proving that $s$ is a section of $v$. Moreover, $\cS(a)=\cS(\id_A;a)=\cS(\id_A);a=s;a$.

\item \emph{\ref{forward-3} implies \ref{forward-1}.}
%
Assume that \ref{forward-3} holds. To show \eqref{eq:shifters are functors}, note that $\cS(a;t)=s;a;t=\cS(a);t$. To show \eqref{eq:forward condition}, consider $a,g,h$ such that $v;g=a;h$; then $g=\id_A;g=s;v;g=s;a;h = \cS(a);h$.
\end{itemize}

\item Assume that $\cS$ is a source shifter such that $\cS(\id_B)=v$.
\begin{itemize}
\item \emph{$v$ epi implies that $\cS$ is a backward source shifter for $v$.} To show \eqref{eq:backward condition}, let $a,g,h$ be such that $v;g=\cS(a);h=v;a;h$; then $g=a;h$ because $v$ is epi.

\item \emph{$\cS$ a backward source shifter for $v$ implies that $v$ is epi.} Let $g,h:B\to C$ be such that $v;g=v;h$, and let $a=\id_B$; then $v;g=\cS(a);h$, hence \eqref{eq:backward condition} implies $g=a;h=\id_B;h=h$. It follows that $v$ is epi.\qed
\end{itemize}
\end{enumerate}
\end{proof}
%
It follows that $v$ has precisely one forward source shifter for every section $s$ of $v$ (meaning, among other things, that $v$ must be a retraction --- and hence at least epi --- to have any forward shifter at all). As for backward source shifters, if $\cS(\id_B)=v$ (which is in general the only known arrow from $A$ to $B$), then $v$ has a backward source shifter if and only if $v$ is epi. We denote these source shifters by $\cF_v^s$ and $\cB_v$, respectively. Their working is visualised in \fcite{ab-source shifters}. \fcite{ex-ab-shifters} shows some examples.

\begin{figure}
\centering
\input{figs/ab-source-shifting}
\caption{Forward and backward source shifting (all subdiagrams commute)}
\flabel{ab-source shifters}
\end{figure}

\begin{figure}
\centering
\input{figs/ex-ab-shifters}
\caption{Forward source shifters $\cF_v^{s_1}$ and $\cF_v^{s_2}$ and backward source shifter $\cB_v$ for an arrow $v:A\to B$. (The arrow $a$ is the identity on nodes.)}
\flabel{ex-ab-shifters}
\end{figure}

Source shifting is extended in a straightforward manner to conditions, where it is called \emph{root shifting}. To root-shift a condition, we only have to source-shift the arrows of its branches: the subconditions remain the same. This also means that for zero-width conditions, there is essentially nothing to be done. Hence we can extend the action of a source shifter $\cS$ from $X$ to $Y$ to conditions $c\in \AC X$ of arbitrary width $|c|=w$, as follows:
\[ \bar\cS: c\mapsto (Y,(\cS(a^c_1),c_1)\ccdots (\cS(a^c_w),c_w)) \enspace. \]
Moreover, for the special case of zero-width conditions, we introduce the special \emph{trivial} root shifter $\cI_{X,Y}$, defined by
\[ \cI_{X,Y}: (X,\epsilon) \mapsto (Y,\epsilon) \enspace. \]

\begin{definition}[root shifter]\dlabel{ab-root shifter}
Let $X,Y$ be objects and $v:A\to B$ an arrow.
\begin{itemize}[topsep=\smallskipamount]
\item A \emph{root shifter} $\cS$ from $X$ to $Y$ is a partial function from $\AC X$ to $\AC Y$ such that either $\cC=\bar\cS$ for some source shifter from $X$ to $Y$, or $\cC=\cI_{X,Y}$.

\item A \emph{forward root shifter} $\cC$ for $v$ is a root shifter from $A$ to $B$ such that either $\cC=\bar\cF$ for some forward source shifter $\cF$, or $\cC=\cI_{A,B}$.

\item A \emph{backward root shifter} $\cC$ for $v$ is a root shifter from $B$ to $A$ such that either $\cC=\bar\cB$ for some backward source shifter $\cB$, or $\cC=\cI_{B,A}$.
\end{itemize}
\end{definition}
%
It should be noted that \emph{all} root shifters $\bar\cS$ with $\cS$ a source shifter from $X$ to $Y$ behave as $\cI_{X,Y}$ on zero-width conditions; however, $\cI_{X,Y}$ is a root shifter for \emph{any} $v$, whereas, as we have seen in \dcite{ab-source shifter}, forward and backward source shifters only exist for certain $v$. This makes it useful to distinguish this special case.

The following fact, which follows from \lcite{ab-source shifters} for source shifters, will be very useful in reasoning about root shifters.
%
\begin{lemma}[root shifter property]\llabel{ab-root shifters}
Let $X,Y$ be objects. For any non-trivial root shifter $\cC$ from $X$ to $Y$, there is an arrow $v:Y\to X$ such that, for all $c\in \AC X$ on which $\cC$ is defined, $\cC(c)= (Y,(v;a^c_1,c_1)\ccdots (v;a^c_{|c|},c_{|c|}))$.
\end{lemma}
%
\begin{proof}
If $\cC$ is non-trivial, then $\cC=\bar\cS$ for some source shifter. Let $v=\cS(\id_X)$; then \lcite{ab-source shifters} implies $\cS(a)=v;a$ for any $A$-sourced $a$.\qed
\end{proof}
%
By ignoring from now on the notational distinction between $\cS$ and $\bar\cS$, we reuse $\cF$ and $\cB$ to range over forward and backward root shifters. The action of a root shifter is visualised in \fcite{root shifting}.
%
\begin{figure}
\centering
\input{figs/root-shifting.tex}
\caption{Root shifting using a source shifter $\cS$: green is shifted to blue}
\flabel{root shifting}
\end{figure}
%
The following is the crucial preservation property of root shifters:
%
\begin{proposition}[root shifters preserve models]\plabel{ab-root shifters preserve}~
Let $v:A\to B$.
\begin{enumerate}[topsep=\smallskipamount]
\item If $c\in \AC A$ and $\cF$ is a forward root shifter for $v$ that is defined on $c$, then $v;g\sat c$ implies $g\sat \cF(c)$.
\item If $c\in \AC B$ and $\cB$ is a backward root shifter for $v$ that is defined on $c$, then $v;g\sat \cB(c)$ implies $g\sat c$.
\end{enumerate}
\end{proposition}
%
\begin{proof}
For zero-width conditions, both clauses are vacuously true. In the remainder assume $|c|>0$ (and hence the root shifters are non-trivial). Let $v:A\to B$.
\begin{enumerate}
\item Let $b=\cF(c)$; then $a^b_i=\cF(a^c_i)$ for all $1\leq i\leq |c|$. Assume $v;g\sat c$ due to responsible branch $p^c_i$ and witness $h$; i.e., $v;g=a^c_i;h$. \eqcite{forward condition} then implies $g=\cF(a);h$, hence $p^b_i$ is a responsible branch and $h$ a witness for $g\sat b$.
\item Let $b=\cB(c)$; then $a^b_i=\cB(a^c_i)$ for all $1\leq i\leq |c|$. Assume $v;g\sat b$ due to responsible branch $p^b_i$ and witness $h$; i.e., $v;g=\cB(a^c_i);h$. \eqcite{backward condition} then implies $g=a;h$, hence $p^c_i$ is a responsible branch and $h$ a witness for $g\sat c$.
\qed
\end{enumerate}
\end{proof}
%
Source and root shifters compose, in the following way.
%
\begin{proposition}[shifters compose]\plabel{ab-shifters compose}
\begin{enumerate}[topsep=\smallskipamount]
\item If $\cU$ is a source [root] shifter from $X$ to $Y$ and $\cV$ a source [root] shifter from $Y$ to $Z$, then $\cU;\cV$ (understood as partial function composition) is a source [root] shifter from $X$ to $Z$. 
\item If $\cU$ and $\cV$ are forward source [root] shifters for $u: X\to Y$ and $v: Y \to Z$, respectively, then $\cU;\cV$ is a forward source [root] shifter for $u;v$.
\item Dually, if $\cU$ and $\cV$ are backward source [root] shifters for $u: Y\to X$ and $v: Z \to Y$, respectively, then $\cU;\cV$ is a backward source [root] shifter for $v;u$.
\end{enumerate}
\end{proposition}

\begin{proof}
We first prove the case for source shifters.
\begin{enumerate}
\item To prove \eqcite{shifters are functors} for $\cU;\cV$ consider:
\[ (\cU;\cV)(a;t) = \cV(\cU(a;t))= \cV(\cU(a);t)=\cV(\cU(a));t=(\cU;\cV)(a);t \enspace. \]

\item In case $\cU$ and $\cV$ are forward, to prove \eqcite{forward condition} assume $u;v;g=a;h$. By applying \eqcite{forward condition} for $\cU$ and $\cV$ it follows that $v;g=\cU(a);h$ and hence $g=\cV(\cU(a));h=(\cU;\cV)(a)$.

\item In case $\cU$ and $\cV$ are backward, to prove \eqcite{backward condition} for $\cU;\cV$ assume $v;u;g=(\cU;\cV)(a);h=\cV(\cU(a));h$. By applying \eqcite{backward condition} for $\cV$ and $\cU$ it follows that $u;g=\cU(a);h$ and hence $g=a;h$.
\end{enumerate}
%
Now assume $\cU$ and $\cV$ are root shifters. If both are non-trivial, then so is $\cU;\cV$ and the result follows by a straightforward pointwise argument. If, on the other hand, either $\cU$ or $\cV$ is trivial, then in fact so is $\cU;\cV$, which immediately establishes the result.
\qed
\end{proof}

\subsection{Structural morphisms}

The following defines structural morphisms based on root shifters over ab-conditions with the same root.

\begin{definition}[arrow-based condition morphism]\dlabel{ab-morphism}
  Given two ab-conditions $b,c \in \AC{R}$, a \emph{forward-shift [backward-shift] condition morphism} $m: b \to c$ is a pair $(o,(v_1,m_1)\ccdots (v_{|b|},m_{|b|}))$ where
  \begin{itemize}[topsep=\smallskipamount]
  \item $o:[1,|b|]\to[1,|c|]$ is a function from $b$'s branches to $c$'s branches;
  \item for all $1\leq i\leq |b|$, $v_i:P^c_{o(i)}\to P^b_i$ is an arrow from the pattern of $p^c_{o(i)}$ to that of $p^b_i$ such that $a^c_{o(i)};v_i=a^b_i$;
  \item\emph{Forward shift}: for all $1\leq i\leq |b|$, there is a forward root shifter $\cF_i$ for $v_i$ such that $m_i:\cF_i(c_{o(i)})\to b_i$ is a forward-shift morphism.
  \item\emph{Backward shift}: for all $1\leq i\leq |b|$, there is a backward root shifter $\cB_i$ for $v_i$ such that $m_i:c_{o(i)}\to \cB_i(b_i)$ is a backward-shift morphism.
  \end{itemize}
\end{definition}
%
We use the same notational conventions as for conditions: $m$ has width $|m|$, and the components of a morphism $m$ are denoted $o^m$, $v^m_i$ and $m_i$ for all $1\leq i\leq |m|$. \fcite{shifted-morphism} visualises the principle of forward- and backward-shift morphisms.
%
\begin{figure}
\centering
\input{figs/shifted-morphisms}
\caption{Forward-shift and backward-shift morphism $m:b\to c$}
\flabel{shifted-morphism}
\end{figure}

The next result states that the existence of a morphism between two conditions $m: b \to c$ provides evidence that $b$ entails $c$.

\begin{proposition}[ab-condition morphisms preserve models]
  \plabel{ab-morphisms preserve models}
Let $b,c \in \AC{R}$  be arrow-based conditions. If $m:b\to c$ is a forward-shift or a backward-shift morphism, then $g\sat b$ implies $g \sat c$ for all arrows $g:R\to G$. 
\end{proposition}

\begin{proof}
Let $m = (o,(v_1,m_1)\ccdots (v_{|b|},m_{|b|}))$ and assume by induction hypothesis that for all $1\leq j\leq |b|$ the property holds for $m_j$. Let $p^b_i$ be the responsible branch and $h: P^b_i \to G$ the witness for $g\sat b$. 
Hence we have $(\dagger)\, g=a^b_i;h$ and $(\ddagger)\, h \nsat b_i$.  
We show that $g \sat c$, with responsible branch $p^c_{o(i)}$ and witness $h$. In fact, we immediately have  $a^c_{o(i)}; v_i ;h = a^b_i ; h \stackrel{(\dagger)}{=} g$. It remains to show that $v_i ;h \nsat c_{o(i)}$, for which we consider separately the two cases.
\begin{enumerate}
\item Let $m$ be a forward-shift morphism. Then for all $1\leq j\leq |b|$ we have that   $m_j:\cF_j(c_{o(j)}) \to b_j$ is a forward-shift morphism, where $\cF_j$ is a forward root shifter for $v_j$. If (ad absurdum) $v_i ;h \sat c_{o(i)}$, by clause 1 of \pcite{ab-root shifters preserve} we would have $h \sat \cF_i(c_{o(i)})$, and by induction hypothesis on $m_i$ also $h \sat b_i$, contradicting $(\ddagger)$.

\item Let $m$ be a backward-shift morphism. Then for all $1\leq j\leq |b|$ we have that  $m_j:c_{o(j)}\to \cB_j(b_j)$ is a backward-shift morphism, where $\cB_j$ is a backward root shifter of width $|b_j|$.
Suppose (ad absurdum) that $v_i ;h \sat c_{o(i)}$. Then by the induction hypothesis on $m_i$ we also have $v_i ;h \sat \cB_i(b_i)$, and by clause 2 of \pcite{ab-root shifters preserve} we  have $h \sat b_i$, contradicting $(\ddagger)$.
\qed
\end{enumerate}
\end{proof}
%
The property that existence of morphims guarantees entailment can be phrased more abstractly as the existence of a functor from a category of conditions and their morphims to $\ABC^{\entails}$. To this aim we first have to show that condition morphims compose. As an (important) intermediate result, we show that root shifters preserve morphisms.

\begin{lemma}[root shifters preserves morphisms]\llabel{ab-root shifters preserve morphisms}
Let $b,c \in  \AC{R}$ and let $\cC$ be a root shifter from $X$ to $Y$ that is defined on $b$ and $c$. If $m = (o,(v_1,m_1)\cdots(v_{|b|},m_{|b|}))$ is a morphism from $b\in \AC X$ to $c\in\AC X$, then it is a morphism from $\cC(b)$ to $\cC(c)$. 
\end{lemma}

\begin{proof}
If $\cC$ is trivial, the result is immediate. Otherwise, let $t$ be as in \lcite{ab-root shifters}. The only new proof obligation is that, for all $1\leq i\leq |b|$, $t;a^c_{o(i)};v_i=t;a^b_i$. This follows immediately from $a^c_{o(i)};v_i=a^b_i$.\qed
\end{proof}
%
Composition of ab-condition morphisms is defined recursively, independently of whether they are forward or backward. Let $m:b\to c$ and $n:c\to e$ be morphisms with $|m|=w$.
%
\[ m;n = (o^m;o^n,(v^n_{o^m(1)};v^m_1,n_{o^m(1)};m_1)\ccdots v^n_{o^m(w)};v^m_w,n_{o^m(w)};m_w)) \enspace.
\]
%
We also (recursively) define the identity on a condition $c$ with $|c|=w$:
%
\[ \id_c = (\id_{[1,w]},(\id_{P^c_1},\id_{c_1})\ccdots (\id_{P^c_w},\id_{c_w})) \]
%
The next lemma shows that the composition of morphisms is well-defined.
%
\begin{lemma}[ab-morphisms compose]\llabel{ab-morphisms compose}
Let $m:b\to c$ and $n:c\to e$ be morphisms and let $|b|=w$.
\begin{enumerate}[topsep=\smallskipamount]
\item If $m$ and $n$ are forward-shift morphisms, then $m;n$ is a forward-shift morphism from $c$ to $e$.
\item If $m$ and $n$ are backward-shift morphisms, then $m;n$ is a backward-shift morphism from $c$ to $e$.
\end{enumerate}
\end{lemma}

\begin{proof}
By induction on the depth of $m$ and $n$. Let $o=o^m;o^n$ and for all $1\leq i\leq w$ let $v_i=v^n_{o^m(i)};v^m_i$. Note that $o$ is a function from $[1,w]$ to $[1,|e|]$ and all $v_i$ are arrows from $P^e_{o(i)}$ to $P^b_i$ as required.
\begin{enumerate}
\item For all $1\leq i\leq |b|$ and $1\leq j\leq |c|$, let $\cF^m_i$ and $\cF^n_j$ be the foward root shifters for $v^m_i$ and $v^n_j$, respectively, guaranteed by the fact that $m$ and $n$ are forward-shift morphisms, i.e., such that $m_i:\cF^m_i(c_{o^m(i)})\to b_i$ and $n_j:\cF^n_j(e_{o^n(j)})\to c_j$ are forward-shift morphisms.

For all $1\leq i\leq w$, we need to show the existence of a forward root shifter $\cF_i$ for $v_i$ such that $n_{o^m(i)};m_i$ is a morphism from $\cF_i(e_{o(i)})$ to $b_i$. Let $j=o^m(i)$ (hence $o^n(j)=o(i)$) and let $\cF_i=\cF^n_j;\cF^m_i$. By \pcite{ab-shifters compose}, $\cF_i$ is a forward root shifter for $v^n_j;v^m_i=v_i$. By definition, $n_j$ is a forward-shift morphism from $\cF^n_j(e_{o^n(j)})$ to $c_j$ and hence by \lcite{ab-root shifters preserve morphisms} (applying $\cF^m_i$) also a forward-shift morphism from $\cF_i(e_{o^n(j)})$ to $\cF^m_i(c_j)$. Again by definition, $m_i$ is a forward-shift morphism from $\cF^m_i(c_j)$ to $b_i$. By the induction hypothesis, therefore, $n_j;m_i$ is a forward-shift morphism from $\cF_i(e_{o(i)})$ to $b_i$.

\item Mutatis mutandis.
\qed
\end{enumerate}
\end{proof}
%
We now state the first main result, that ab-conditions endowed with either forward or backward morphisms give rise to a category with a functor to $\ABC^{\entails}$

\begin{theorem} 
Let $\ABC^{\forw}$ be the category having ab-conditions as objects and forward-shift morphims as arrows, and let $\ABC^{\back}$ be the category having the same objects and backward-shift morphisms as arrows. They are well-defined, and there are identity-on-objects functors $\ABC^{\forw} \to \ABC^{\entails}$ and $\ABC^{\back} \to \ABC^{\entails}$
\end{theorem}
%
\emph{Proof sketch.} Composition of morphisms was shown by \lcite{ab-morphisms compose}.
Observing that, for any $A$, the identity function on $A$-sourced arrows is both a forward and backward source shifter for $\id_A$, and hence gives rise to a forward and backward root shifter for $\id_A$, it is routine to check that for each ab-condition $c$ the identity morphism $id_c$ is both a forward-shift and a backward-shift morphism. Moreover, identity morphisms and morphism composition satisfy the unit and associativity laws. The existence of the two identity-on-object functors follows from \pcite{ab-morphisms preserve models}.
\qed 

\medskip\noindent
Even though both forward- and backward-shift morphisms preserve models, they are incomparable: if two conditions are related by one kind of morphisms they are not necessarily related by the other kind. In other words, if we consider the existence of a morphism as ``explaining'' some cases of entailment of conditions, then these two types of morphism are complementary. This is shown by the following two examples.\todo{AC: In both examples a common root has to be added (e.g. containing just $\{x,y\}$). To let morphims go from left to right conditions $c_1$ and $c_2$ should be switched, as well as $c_3$ and $c_4$.}
%
\begin{figure}
\centering
\subcaptionbox
  {A forward-shift morphism for which there is no backward-shift one
   \flabel{forward-no-backward}
  }
  [.45\textwidth]
  {\input{figs/ex-forward-no-backward}}
  \qquad
\subcaptionbox
  {A backward-shift morphism for which there is no forward-shift one
   \flabel{backward-no-forward}
  }
  [.45\textwidth]
  {\input{figs/ex-backward-no-forward}}
\caption{Forward-shift versus backward-shift morphisms}
\flabel{forward vs backward}
\end{figure}
%
\begin{example}\exlabel{forward-no-backward}
\fcite{forward-no-backward} shows a forward-shift morphism that does not have a corresponding backward-shift one. Both are evaluated in a context where we know $\la(x,z)$.
\begin{itemize}
\item $b$ encodes the property $\neg \lb(z,x)$;
\item $c$ encodes $\exists y\st \la(x,y) \wedge \neg \lb(z,x)$.
\end{itemize}
Clearly, $b$ (logically) entails $c$ because $y$ can be instantiated with the value of $z$. The figure shows $\cF_v^s(a^c_{11})$ (for one of the sections $s$ of $v$), which act as the identity. 
\end{example}
%
\begin{example}\exlabel{backward-no-forward}
\fcite{backward-no-forward} shows a backward-shift morphism that does not have a corresponding forward-shift one. Both are evaluated in a context where we know $\la(x,y)$.
\begin{itemize}
\item $b$ encodes the property $\lb(y,y) \wedge \nexists z\st \lc(z,x)$;
\item $c$ encodes the property $\exists z.\lb(z,z) \wedge \neg(y=z \wedge \lc(y,x))$.
\end{itemize}
Clearly, $b$ (logically) entails $c$ because $z$ can be instantiated with the value of $y$.
\todo{AR: to be extended}
\end{example}
%
Further\todo{AC: to adjust or delete. AR: rest of the section unchanged} comparing the two notions of morphism, note that retractions are epi in any category, but not vice versa: for example, in \cat{Graph} there are epis which do not have a section (an example being $t'$ in \fcite{epi-no-retraction}). Therefore, asking for the existence of a section is a stronger condition than being an epi, suggesting that every retraction-based morphism may be epi-based, but certainly not vice versa. However, this also fails to be the case, for two reasons:
%
\begin{itemize}
\item The existence of a section (in retraction-based morphisms) is only required when the source condition has branches, whereas our definition of epi-based morphism asks for all arrows to be epi.
\item The commutativity requirement for epi-based morphisms is stronger than the one for retraction-based morphisms: if there is a section $s_i: R_c \to R_b$ for $t$, then \eqcite{simple ab-morphism} implies \eqcite{ab-morphism} but not the other way around.
\end{itemize}
%
While the discrepancy in the first bullet could be resolved by only requiring those arrows in an epi-based morphism to be epi that start in a condition with sub-branches (this does not invalidate the proof of \pcite{epi-based implies entailment}), the second is more fundamental. Fur instance, in \excite{retraction-not-epi}, no epi-based morphism $m:c_1\to c_2$ exists, even under this relaxed condition.

There is no unequivocal evidence which one of these is the ``best" or ``most useful". For example, when instantiating arrow-based conditions in the category of cospans (as advocated by \cite{bchk:conditional-reactive-systems}), the notion of retraction-based morphism is all but useless, because in that category, only trivial cospans (in which both legs are epi) can be retractions. On the other hand, when we move to span-based conditions in the sequel, it will turn out out that retraction-based morphisms extend naturally whereas epi-based morphisms do not.