\section{Morphisms of arrow-based conditions}

The notion of \emph{morphism} of nested conditions has not received much attention in the literature. When considered at all, such as in \cite{bchk:conditional-reactive-systems,sksclo:coinductive-techniques-for-satisfiability}, they are essentially based on the semantics in terms of satisfaction. Indeed, entailment establishes a preorder over conditions. Let us denote the resulting category $\ABC^{\entails}$.

The question that we address in this section is to establish a meaningful \emph{structural} notion of condition morphism. That is, given the fact that an ab-condition is essentially a diagram in the category $\bC$, a structural morphism from $b$ to $c$ consists of arrows between objects of $b$ and objects of $c$ satisfying certain commutativity conditions. For morphisms to be meaningful, they should certainly only exist where there is entailment; in other words, we require there to be a functor to $\ABC^{\entails}$. As we will see, this requirement implies that it is not enough to consider only arrows from objects of $b$ \emph{to} objects of $c$, since in our definition of satisfaction, the direction of entailment flips at every subsequent nesting level. We also observe that the existence of a functor to $\ABC^{\entails}$ means that we only consider morphisms between conditions with the same root.

The underlying principle for a morphism $m$ from $b=(R,p^b_1\ccdots p^c_{|b|})$ to $c=(R,p^c_1\ccdots p^c_{|c|})$ is that it must identify, for every $b$-branch $p^b_i$, a $c$-branch $p^c_j$ that entails it. Entailment of branches, in turn, is captured by the existence of an arrow $v_i$ from $P^c_j$ to $P^b_i$ (hence going in the \emph{opposite} direction of $m$) such that there is (recursively, but in the opposite direction) a morphism between the subconditions $c_j$ and $b_i$; however, this sub-morphism can only exist ``modulo" the morphism $v_i$ between their roots. The main task of the next subsection is to make the concept of ``modulo $v_i$" precise.

\subsection{Root shifting}

In order to relate conditions at different roots, we introduce a special kind of mapping called a \emph{root shifter}, which will later turn out to be functors between categories of conditions. For now, we note that the purpose of root shifters is to relate the models of a condition $b$ to those of a condition $c$, given an arrow $v:R^b\to R^c$ between their roots (the existence of which implies that the model sets are typically disjoint). To be more precise, we will require that \emph{every $v$-prepended model of $b$ induces a model for $c$}: that is, if $v;g$ is a model of $b$, then $g$ is a model of $c$.

This can be achieved in essentially two ways, on the basis of $v$: by constructing $c$ from $b$ (which we will call \emph{forward shifting}) or by constructing $b$ from $c$ (which we will call \emph{backward shifting}).

We will first define the notion of shifting for arrows (where it is called source shifting) and then extend this in a natural way to conditions (where it is called root shifting).

\begin{definition}[source shifter]\dlabel{ab-source-shifter}
Let $X,Y$ be objects. A \emph{source shifter} $\cS$ from $X$ to $Y$ is a function from $X$-sourced arrows to $Y$-sourced ones having the same target, say $Z$, such that for all $t$ with source $Z$:
%
\begin{equation}\eqlabel{shifters are functors}
\cS(a;t) = \cS(a);t \enspace.
\end{equation}
%
Now let $v=A\to B$ be an arrow. $\cS$ is a \emph{forward source shifter for $v$} if it  is a source shifter from $A$ to $B$ such that for all $a:A\to C$, $g:B\to G$ and $h:C\to G$:
%
\begin{equation}\eqlabel{forward condition}
v;g = a;h \text{ implies } g = \cS(a);h \enspace.
\end{equation}
%
Instead, $\cS$ is a \emph{backward source shifter for $v$} if it is a source shifter from $B$ to $A$ such that for all $a:B\to C$, $g:B\to G$ and $h:C\to G$:
%
\begin{equation}\eqlabel{backward condition}
v;g = \cS(a);h \text{ implies } g = a;h \enspace.
\end{equation}
\end{definition}
%
Condition \eqref{eq:shifters are functors} is actually quite strong, since it holds for any arrow $a$ and $t$; in particular also for the case that $a=\id_X$ (and hence $Z=X$). Thus we can easily deduce, for any arrow $v:X\to V$:
%
\[ \cS(v) = \cS(\id_X;v) = \cS(\id_X);v \]
%
implying that the action of a source shifter $\cS$ from $X$ to $Y$ simply consists of prepending the image of $\cS(\id_X)$ to its argument. In turn, knowing that $\cS(t)=v;t$ for some $v$ (namely, $\cS(\id_X)$) is enough to prove \eqcite{shifters are functors}.
%
\begin{lemma}[source shifter properties]\llabel{ab-source-shifters}
The following two statements are equivalent.
\begin{enumerate}[label=(\alph*),ref=(\alph{enumi})]
\item\label{shifter-2} $\cS$ is a mapping from $B$-sourced arrows to $A$-sourced arrows such that $\cS(a)=v;a$ for all $a:B\to C$.
\item\label{shifter-1} $\cS$ is a source shifter from $B$ to $A$ such that $\cS(\id_B)=v$;
\end{enumerate}
\end{lemma}

\begin{proof}~
\begin{itemize}
\item \emph{\ref{shifter-2} implies \ref{shifter-1}.}
%
Assume that \ref{shifter-2} holds. To show \eqref{eq:shifters are functors}, note that $\cS(a;t)=v;a;t=\cS(a);t$. Furthermore, $\cS(\id_B)=v;\id_B=v$.\qed

\item \emph{\ref{shifter-1} implies \ref{shifter-2}.}
%
Assume that \ref{shifter-1} holds. By definition, $\cS$ is a mapping from $B$-sourced arrows to $A$-sourced arrows. Now let $a:B\to C$; by \eqref{eq:shifters are functors}, it follows that $\cS(a)=\cS(\id_B;a)=\cS(\id_B);a=v;a$.
\end{itemize}
\end{proof}

This in turn implies that source shifters are entirely determined by $\cS(\id_X)$, which can form a basis for their construction.

If $\cS$ is known to be a forward shifter, we often use $\cF$ to denote it; similarly, we often use $\cB$ to denote backward shifters. The following proposition characterises the (forward and backward) root shifters.
%
\begin{proposition}[source shifter characterisation]\plabel{ab-source-shifters}
Let $v:A\to B$ be an arrow.
\begin{enumerate}
\item The following three statements are equivalent.
\begin{enumerate}[label=(\alph*),ref=\theenumi(\theenumii)]
\item\label{forward-1} $\cS$ is a forward source shifter for $v$;
\item\label{forward-2} $\cS$ is a source shifter from $A$ to $B$ such that $\cS(v)=\id_B$;
\item\label{forward-3} $\cS$ is a mapping from $A$-sourced arrows to $B$-sourced arrows such that $s=\cS(\id_A)$ is a section of $v$ and $\cS(a)=s;a$ for all $a:A\to C$.
\end{enumerate}
\item If $\cS$ is a source shifter such that $\cS(\id_B)=v$, then $\cS$ is a backward source shifter for $v$ if and only if $v$ is epi.
\end{enumerate}
\end{proposition}
%
\begin{proof}~
\begin{enumerate}
\item
We show $\ref{forward-1} \Rightarrow \ref{forward-2} \Rightarrow \ref{forward-3} \Rightarrow \ref{forward-1}$.
\begin{itemize}
\item \emph{\ref{forward-1} implies \ref{forward-2}.}
%
Assume that \ref{forward-1} holds. By definition, $\cS$ is a source shifter from $A$ to $B$. Now consider \eqref{eq:forward condition} with $a=v$ and $g=h=\id_B$: then $v;g=a;h$, hence $\id_B=g = \cS(a);h=\cS(a)$.

\item \emph{\ref{forward-2} implies \ref{forward-3}.}
%
Assume that \ref{forward-2} holds. By definition, $\cS$ is a mapping from $A$-sourced arrows to $B$-sourced arrows; moreover, if $s=\cS(\id_A)$ then $s;v=\cS(\id_A);v=\cS(\id_A;v)=\cS(v)=\id_B$, proving that $s$ is a section of $v$. Moreover, $\cS(a)=\cS(\id_A;a)=\cS(\id_A);a=s;a$.

\item \emph{\ref{forward-3} implies \ref{forward-1}.}
%
Assume that \ref{forward-3} holds. To show \eqref{eq:shifters are functors}, note that $\cS(a;t)=s;a;t=\cS(a);t$. To show \eqref{eq:forward condition}, consider $a,g,h$ such that $v;g=a;h$; then $g=\id_A;g=s;v;g=s;a;h = \cS(a);h$.
\end{itemize}

\item Assume that $\cS$ is a source shifter such that $\cS(\id_B)=v$.
\begin{itemize}
\item \emph{$v$ epi implies that $\cS$ is a backward source shifter for $v$.} To show \eqref{eq:backward condition}, let $a,g,h$ be such that $v;g=\cS(a);h=v;a;h$; then $g=a;h$ because $v$ is epi.

\item \emph{$\cS$ a backward source shifter for $v$ implies that $v$ is epi.} Let $g,h:B\to C$ be such that $v;g=v;h$, and let $a=\id_B$; then $v;g=\cS(a);h$, hence \eqref{eq:backward condition} implies $g=a;h=\id_B;h=h$. It follows that $v$ is epi.\qed
\end{itemize}
\end{enumerate}
\end{proof}
%
It follows that $v$ has precisely one forward source shifter for every section $s$ of $v$ (meaning, among other things, that $v$ must be a retraction (and hence at least epi) to have any forward shifter at all). As for backward source shifters, if $\cS(\id_B)=v$ (which is in general the only known arrow from $A$ to $B$), then $v$ has a backward source shifter if and only if $v$ is epi. We denote these source shifters by $\cF_v^s$ and $\cB_v$, respectively. They are visualised in \fcite{source shifters}.

\begin{figure}
\centering
\input{figs/source-shifting}
\caption{Forward and backward source shifting (all subdiagrams commute)}
\flabel{source shifters}
\end{figure}

Source shifting is extended in a straightforward manner to conditions, where it is called \emph{root shifting}. To root-shift a condition, we only have to source-shift the arrows of its branches: the subconditions remain the same. This also means that for zero-width conditions, there is essentially nothing to be done. Hence we can extend the action of a source shifter $\cS$ from $X$ to $Y$ to conditions $c\in \AC X$ of arbitrary width $|c|=w$, as follows:
\[ \bar\cS: c\mapsto (Y,(\cS(a^c_1),c_1)\ccdots (\cS(a^c_w),c_w)) \enspace. \]
Moreover, for the special case of trivial (zero-width) conditions, we introduce the special \emph{trivial} root shifter $\cI_{X,Y}$, defined by
\[ \cI_{X,Y}: (X,\epsilon) \mapsto (Y,\epsilon) \enspace. \]
%
\begin{definition}[root shifter]\dlabel{ab-root-shifter}
Let $v:A\to B$ be an arrow.
\begin{itemize}
\item A \emph{forward root shifter} $\cC$ for $v$ is a partial function from $\AC A$ to $\AC B$ such that either $\cC=\bar\cF$ for some forward source shifter $\cF$, or $\cC=\cI_{A,B}$.

\item A \emph{backward root shifter} $\cC$ for $v$ is a partial function from $\AC B$ to $\AC A$ such that either $\cC=\bar\cB$ for some backward source shifter $\cB$, or $\cC=\cI_{B,A}$.
\end{itemize}
\end{definition}
%
If should be noted that \emph{all} root shifters $\bar\cS$ with $\cS$ a source shifter from $X$ to $Y$ behave as $\cI_{X,Y}$ on zero-width conditions; however, $\cI_{X,Y}$ is a root shifter for \emph{any} $v$, whereas, as we have seen in \dcite{ab-source-shifter}, forward and backward source shifters only exist for certain $v$. This makes it useful to distinguish this special case.

The following fact, which follows from \lcite{ab-source-shifters} for source shifters, will be very useful in reasoning about root shifters.
%
\begin{lemma}[root shifter property]\llabel{ab-root-shifters}
For any non-trivial root shifter $\cC$ from $A$ to $B$, there is a $t:A\to B$ such that, for all $c\in \AC A$ on which $\cC$ is defined, $\cC(c)= (B,(t;a^c_1,c_1)\ccdots (t;a^c_{|c|},c_{|c|}))$.
\end{lemma}
%
\begin{proof}
If $\cC$ is non-trivial, then $\cC=\bar\cS$ for some source shifter then this follows immediately from \lcite{ab-source-shifters}, with $t=\cS(\id_A)$.\qed
\end{proof}
%
We use $\cC$ to range over root shifters, and by ignoring from now on the notational distinction between $\cS$ and $\bar\cS$, also reuse $\cF$ and $\cB$ for forward and backward root shifters. The action of a root shifter is visualised in \fcite{root shifting}.
%
\begin{figure}
\centering
\input{figs/root-shifting.tex}
\caption{Root shifting using a source shifter $\cS$: green is shifted to blue}
\flabel{root shifting}
\end{figure}
%
The following is the crucial preservation property of root shifters:
%
\begin{proposition}[root shifters preserve models]\plabel{ab-root-shifters preserve}~
Let $v:A\to B$.
\begin{enumerate}
\item If $c\in \AC A$ and $\cF$ is a forward root shifter for $v$ that is defined on $c$, then $v;g\sat c$ implies $g\sat \cF(c)$.
\item If $c\in \AC B$ and $\cB$ is a backward root shifter for $v$ that is defined on $c$, then $v;g\sat \cB(c)$ implies $g\sat c$.
\end{enumerate}
\end{proposition}
%
Source and root shifters compose, in the following way.
%
\begin{proposition}~
\begin{enumerate}
\item If $\cU$ is a source [root] shifter from $X$ to $Y$ and $\cV$ a source [root] shifter for from $Y$ to $Z$, then $\cU;\cV$ (understood as partial function composition) is a source [root] shifter from $X$ to $Z$. 
\item If $\cU$ and $\cV$ are forward source [root] shifters for $u: X\to Y$ and $v: Y \to Z$, respectively, then $\cU;\cV$ is forward source [root] shifter for $u;v$.
\item Dually, if $\cU$ and $\cV$ are backward sort [root] shifters for $u: Y\to X$ and $v: Z \to Y$, respectively, then $\cU;\cV$ is a backward source [root] shifter for $v;u$.
\end{enumerate}
\end{proposition}

\begin{proof}
We first prove the case for source shifters.
\begin{enumerate}
\item To prove \eqcite{shifters are functors} for $\cU;\cV$ consider:
\[ (\cU;\cV)(a;t) = \cV(\cU(a;t))= \cV(\cU(a);t)=\cV(\cU(a));t=(\cU;\cV)(a);t \enspace. \]

\item In case $\cU$ and $\cV$ are forward, to prove \eqcite{forward condition} assume $a\commutes (u;v;g,h)$; then (in two steps) $\cU(a)\commutes (v;g,h)$ and $\cV(\cU(a))\commutes (g,h)$. Since $\cV(\cU(a))=(\cU;\cV)(a)$, we are done.

\item In case $\cU$ and $\cV$ are backward, to prove \eqcite{backward condition} assume $(\cU;\cV)(a)\commutes (v;u;g,h)$. Since $(\cU;\cV)(a)=\cV(\cU(a))$, in two steps it follows that $\cU(a)\commutes (u;g,h)$ and hence $a\commutes (g,h)$.
\end{enumerate}
Now assume $\cU$ and $\cV$ are root shifters. If both are non-trivial, then so is $\cU;\cV$ and the result follows by a straightforward pointwise argument. If, on the other hand, either $\cU$ or $\cV$ is trivial, then in fact so is $\cU;\cV$, which immediately establishes the result.
\qed
\end{proof}

\subsection{Structural morphisms}

The following defines structural morphisms based on root shifters over ab-conditions with the same root.

\begin{definition}[arrow-based condition morphism]\dlabel{ab-morphism}
  Given two ab-conditions $b,c \in \AC{R}$, a \emph{forward-shift [backward-shift] condition morphism} $m: b \to c$ is a pair $(o,(v_1,m_1)\ccdots (v_{|b|},m_{|b|}))$ where
  \begin{itemize}
  \item $o:[1,|b|]\to[1,|c|]$ is a function from $b$'s branches to $c$'s branches;
  \item for all $1\leq i\leq |b|$, $v_i:P^c_{o(i)}\to P^b_i$ is a mapping from the pattern of $p^c_{o(i)}$ to that of $p^b_i$ such that $a^c_{o(i)};v_i=a^b_i$;
  \item\emph{Forward shift}: for all $1\leq i\leq |b|$, there is a forward root shifter $\cF,i$ for $v_i$ such that $m_i:\cF_i(c_{o(i)})\to b_i$ is a forward-shift morphism.
  \item\emph{Backward shift}: for all $1\leq i\leq |b|$, there is a backward root shifter $\cB_i$ for $v_i$ such that $m_i:c_{o(i)}\to \cB_i(b_i)$ is a backward-shift morphism.
  \end{itemize}
\end{definition}
%
\fcite{shifted-morphism} visualises the principle of forward- and backward-shift morphisms.
%
\begin{figure}
\centering
\input{figs/shifted-morphisms}
\caption{Forward-shift and backward-shift morphism $m:b\to c$}
\flabel{shifted-morphism}
\end{figure}

The next result states that the existence of a morphism between two conditions $m: b \to c$ witnesses that $b$ entails $c$.

\begin{proposition}[shift ab-condition morphisms preserve models]
  \plabel{ab-preserve-satisfaction}
Let $b,c \in \AC{R}$  be arrow-based conditions. If $m:b\func c$ is a forward-shift or a backward-shift morphism, then $g\sat b$ implies $g \sat c$ for all arrows $g:R\func G$. 
\end{proposition}

\begin{proof}
Let $m = (o,(v_1,m_1)\ccdots (v_{|b|},m_{|b|}))$ and assume by induction hypothesis that for all $1\leq j\leq |b|$ the property holds for $m_j$. Let $p^b_i$ be the responsible branch and $h: P^b_i \to G$ the witness for $g\sat b$. 
Hence we have $(\dagger)\, g=a^b_i;h$ and $(\ddagger)\, h \nsat b_i$.  
We show that $g \sat c$, with responsible branch $p^c_{o(i)}$ and witness $a^c_{o(i)}; v_i ;h$. In fact, we immediately have  $a^c_{o(i)}; v_i ;h = a^b_i ; h \stackrel{(\dagger)}{=} g$. It remains to show that $v_i ;h \nsat c_{o(i)}$, for which we consider separately the two cases.
\begin{enumerate}
\item Let $m$ be a forward-shift morphism. Then for all $1\leq j\leq |b|$ we have that   $m_j:\cF_j(c_{o(j)}) \to b_j$ is a forward-shift morphism, where $\cF_j$ is a forward root shifter for $v_j$. If (ad absurdum) $v_i ;h \sat c_{o(i)}$, by clause 1 of \pcite{ab-root-shifters preserve} we would have $h \sat \cF_i(c_{o(i)})$, and by induction hypothesis on $m_i$ also $h \sat b_i$, contradicting $(\ddagger)$.

\item Let $m$ be a backward-shift morphism. Then for all $1\leq j\leq |b|$ we have that  $m_j:c_{o(j)}\to \cB_j(b_j)$ is a backward-shift morphism, where $\cB_j$ is a backward root shifter of width $|b_j|$.
Suppose (ad absurdum) that $v_i ;h \sat c_{o(i)}$. Then by the induction hypothesis on $m_i$ we also have $v_i ;h \sat \cB_i(b_i)$, and by clause 2 of \pcite{ab-root-shifters preserve} we  have $h \sat b_i$, contradicting $(\ddagger)$.
\qed
\end{enumerate}
\end{proof}
%
The property that existence of morphims guarantees entailment can be phrased more abstractly as the existence of a functor from a category of conditions and their morphims to $\ABC^{\entails}$. To this aim we first have to show that condition morphims compose. Let us start with backward-shift morphisms.

\begin{lemma}[root shifters preserves morphisms]\llabel{ab-root-shifters preserve morphisms}
Let $b,c \in  \AC{R}$ and let $\cC$ be a root shifter from $R$ to $R'$. If $m = (o,(v_1,m_1)\cdots(v_{|b|},m_{|b|}))$ is a morphism from $b$ to $c$, then it is a morphism from $\cC(b)$ to $\cC(c)$. 
\end{lemma}

\begin{proof}
If $\cC$ is trivial, the result is immediate. Otherwise, let $t$ be as in \lcite{ab-root-shifters}. The only new proof obligation is that, for all $1\leq i\leq |b|$, $t;a^c_{o(i)};v=t;a^b_i$. This follows immediately from $a^c_{o(i)};v=a^b_i$.\qed
\end{proof}
  
\begin{lemma}
  Backward-shift morphisms compose.
\end{lemma}

\begin{proof}
Let $m' = (o',(v'_1,m'_1)\cdots(v'_{|b|},m'_{|b|})): b \to c$ and 
$m'' = (o'',(v''_1,m''_1)\cdots(v''_{|c|},m''_{|c|})): c \to e$ be backward-shift morphisms.  The composed morphism $m = m' ; m'' = (o,(v_1,m_1)\cdots(v_{|b|},m_{|b|})): b \to e$ has $o = o'' \circ o': [1,|b|] \to [1,|e|]$ as first component. Next for each $1\leq i \leq b$, we set $v_i = v''_{o_i} ; v'_i$.  

For each $1\leq i \leq |b|$ we have $m'_i: c_{o'(i)} \to \cB'_i(b_i)$, where $\cB'_i$ is the backward shifter along $v'_i$. 
By \, since $v''_{o(i)}$ is epi (unless $|c_o(i)| = 0$\todo{AC: trivial case?}),  $m'_i$ is also a morphism from $\cC_{\cB'',i}(c_{o'(i)})$  to $\cC_{\cB'',i}(\cC_{\cB',i}(b_i))$, where $\cC_{\cB'',i}$ is the backward shifter along $v''_{o(i)}$. Also, $m''_{o'(i)}: e_{o''(o'(i))} \to \cC_{\cB'',i}(c_{(o(i))})$. Finally we take $m_i = m''_{o'(i)}; m'_i : e_{o''(o'(i))} \to \cC_{\cB'',i}(\cC_{\cB',i}(b_i))$, which has the desired source and target. Note that there is a circularity in the argument, because we used $m''_{o'(i)}; m'_i$ to define composition. However, the last morphism are at a deeper level in the conditions: the problem can be fixed with a definition by induction on the depth of morphisms.  \qed
\end{proof}

\begin{theorem} 
Let $\ABC^{\to}$ be the category having ab-conditions as objects and forward-shift morphims as arrows, and let $\ABC^{\twoheadleftarrow}$ be the category having the same objects and epi-based backward-shift morphisms as arrows. They are well-defined, and there are identity-on-objects functors $\ABC^{\to} \to \ABC^{\entails}$ and $\ABC^{\twoheadleftarrow} \to \ABC^{\entails}$
\end{theorem}
\emph{Proof sketch.}
It is routine to check that for each ab-condition $b$ on $R$ the identity morphism $id_b = (id_{[1,|b|]},(id_{P^b_1},id_{c_1})\ccdots (id_{P^b_{|b|}},id_{c_{|b|}}))$ is both a forward-shift and an epi-based backward-shift morphisms, and that both classes of morphisms compose and satisfy the unit and associativity laws.\todo{AC: todo?} The existence of the two identity-on-object functors follows from \pcite{ab-preserve-satisfaction}.
\qed 


This depends on the following intermediate result.\todo{AC: delete the lemma? Is it needed?}

\begin{lemma}
Let $b\in \AC A$ and $c\in \AC B$ with $w=|b|=|c|$, and let $\cS$ be a forward root shifter for $v:A\to B$. There exists a morphism $m:\cS(b)\to c$ if and only if there exists a morphism $n:b\to e$ for some condition $e\in \AC A$ such that $c=\cS(e)$.
\end{lemma}
%
\begin{proof}
In fact, $n=m$ as far as the actual structure of the morphism is concerned; the only difference is in the source and target roots ($B$ for $m$, $A$ for $n$).

\qed
\end{proof}

Even though both forward-shift morphisms and epi-based backward-shift ones preserve models, they are incomparable: if two conditions are related by one kind of morphisms they are not necessarily related by the other kind. In other words, if we consider the existence of a morphism as ``explaining'' some cases of entailment of conditions, then these two types of morphism are complementary. This is shown by the following two examples.\todo{AC: In both examples a common root has to be added (e.g. containing just $\{x,y\}$). To let morphims go from left to right conditions $c_1$ and $c_2$ should be switched, as well as $c_3$ and $c_4$.}
%
\begin{figure}
\centering
\subcaptionbox
  {A forward-shift morphism where there is no epi-based backward-shift one
   \flabel{retraction-no-epi}
  }
  {\input{figs/ex-retraction-no-epi}}
  \qquad
\subcaptionbox
  {An epi-based backward-shift morphism where there is no forward-shift one
   \flabel{epi-no-retraction}
  }
  {\input{figs/ex-epi-no-retraction}}
\caption{Retraction-based versus epi-based morphisms}
\flabel{retraction versus epi}
\end{figure}
%
\begin{example}\exlabel{retraction-no-epi}
\fcite{epi-no-retraction} \todo{AC: to be updated} shows two ab-conditions between which there exists an retraction-based morphism (shown in the figure) but no epi-based one.
\begin{itemize}
\item $c_1$ encodes the property $\lb(z,x)$, in a context where we know $\la(x,y)\wedge \la(x,z)$;
\item $c_2$ also encodes $\lb(z,x)$, but now in a context where we (only) know $\la(x,z)$.
\end{itemize}
The top-level arrow $t$ modifies the context of $c_1$ to that of $c_2$ by equating $y=z$; the existence of the morphism $(t,\setof{1\mapsto 1},v)$ with $s;t=\id$ and $s;a_1=a_2;v$ implies that, in that modified context, $c_1$ implies $c_2$ --- which is obviously correct. However, no epi-based morphism exists, since $t$ is the only arrow from $R^{c_1}$ to $R^{c_2}$ and the requirement for an epi-based morphism is that $t;a_2;w=a_1$ for some arrow $w$, which cannot be satisfied because $a_1(x)\neq a_1(z)$ whereas $(t;a_2)(x)=(t;a_1)(z)$.
\end{example}
%
\begin{example}\exlabel{epi-no-retraction}
\fcite{epi-no-retraction}\todo{AC: to be updated} shows two ab-conditions between which there exists an epi-based morphism (shown in the figure) but no retraction-based one.
\begin{itemize}
\item $c_3$ encodes the property $\lc(y,x)\wedge y=z$, in a context where $\la(x,y)\wedge \lb(z,z)$;
\item $c_4$ encodes the property $\exists z.\lc(z,x)$, in a context where $\la(x,y)\wedge \lb(y,y)$.
\end{itemize}
The top-level arrow $t'$ modifies the context of $c_3$ to that of $c_4$ by equating $y=z$; the existence of the epi-based morphism $(t',\setof{1\mapsto 1},v')$ with $a_3=t';a_4;v'$ implies that, in that modified context, $c_3$ implies $c_4$ --- which is clearly correct. However, no retraction-based morphism exists, since $t'$ (which is the only arrow from $R^{c_3}$ to $R^{c_4}$) is not a retraction.
\end{example}
%
Further\todo{AC: to adjust or delete} comparing the two notions of morphism, note that retractions are epi in any category, but not vice versa: for example, in \cat{Graph} there are epis which do not have a section (an example being $t'$ in \fcite{epi-no-retraction}). Therefore, asking for the existence of a section is a stronger condition than being an epi, suggesting that every retraction-based morphism may be epi-based, but certainly not vice versa. However, this also fails to be the case, for two reasons:
%
\begin{itemize}
\item The existence of a section (in retraction-based morphisms) is only required when the source condition has branches, whereas our definition of epi-based morphism asks for all arrows to be epi.
\item The commutativity requirement for epi-based morphisms is stronger than the one for retraction-based morphisms: if there is a section $s_i: R_c \to R_b$ for $t$, then \eqcite{simple ab-morphism} implies \eqcite{ab-morphism} but not the other way around.
\end{itemize}
%
While the discrepancy in the first bullet could be resolved by only requiring those arrows in an epi-based morphism to be epi that start in a condition with sub-branches (this does not invalidate the proof of \pcite{epi-based implies entailment}), the second is more fundamental. Fur instance, in \excite{retraction-not-epi}, no epi-based morphism $m:c_1\to c_2$ exists, even under this relaxed condition.

There is no unequivocal evidence which one of these is the ``best" or ``most useful". For example, when instantiating arrow-based conditions in the category of cospans (as advocated by \cite{bchk:conditional-reactive-systems}), the notion of retraction-based morphism is all but useless, because in that category, only trivial cospans (in which both legs are epi) can be retractions. On the other hand, when we move to span-based conditions in the sequel, it will turn out out that retraction-based morphisms extend naturally whereas epi-based morphisms do not.