\section{Background: nested conditions and satisfaction}
 
\begin{definition}[nested condition]\dlabel{nested condition}
  A \emph{nested condition} $C$ is a pair $\tupof{A,\setof{(f_i,C_i)}_{1\leq i\leq n}}$ where $A$ is an object called the \emph{root} of $C$, $n\geq 0$ is the \emph{degree} of $C$, and for all $1\leq i\leq n$, $C_i$ is a nested condition and $f_i\colon A\func A_i$ is an arrow to the root $A_i$ of $C_i$.
\end{definition}
%
\emph{Terminology and notation:} Given a condition $C$, we will use $A_C$ to denote its root and $f^C_i,C_i$ to denote its constituent morphisms and subconditions --- or just $f_i$ if the identity of $C$ is clear from the context. The degree of $C$ is denoted $\degr C$. We also say that $(f,C')$ is a \emph{branch} of $C$ and write $(f,C')\in C$ to mean that $f=f_i$ and $C'=C_i$ for one of the $1\leq i\leq n$. Pictorially, $C$ can be visualised as in \fcite{nested condition}.
%
\begin{figure}
  \centering
  \input{figs/nested-condition}
  \caption{Pictorial representation of a nested condition}
  \flabel{nested condition}
\end{figure}

\medskip\noindent A nested condition expresses a property of arrows from its root to an arbitrary object. This is operationalised through the notion of \emph{satisfaction}.

\begin{definition}[satisfaction of nested conditions]\dlabel{satisfaction}
  Let $C$ be a nested condition and $g:A_C\func G$ an arrow from $C$'s root to an object $G$. We say that \emph{$g$ satisfies $C$}, denoted $g\sat C$, if there is a branch $(f,C')\in C$ and an arrow $h:A_{C'}\func G$ such that
  \begin{itemize}
  \item $g=f;h$
  \item $h\nsat C'$.
  \end{itemize}
\end{definition}
%
\emph{Terminology and notation.} We call $(f,C')\in C$ the \emph{responsible branch} and $h$ the \emph{witness} of $g\sat C$. Pictorially, $g\sat C$ with responsible branch $(f_i,C_i)$ and witness $h$ can be visualised as in \fcite{nested satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/nested-satisfaction}
  \caption{Pictorial representation $g\sat C$}
  \flabel{nested satisfaction}
\end{figure}

\section{Decomposed conditions}

We now present one of the main ideas of this paper based on the observation that there is a lot of duplication in a nested condition: the children of a node essentially contain all the structure of that (parent) node, and add some constraints on top of it. It turns out to be possible to avoid this duplication by only specifying the \emph{additional} constraints. This is captured by the following definition:

\begin{definition}[decomposed condition]\dlabel{decomposed condition}
  A \emph{decomposed condition} $C$ is a pair $\tupof{A,\setof{(u_i,d_i,C_i)}_{1\leq i\leq n}}$ where $A$ is an object called the \emph{root} of $C$, $n\geq 0$ is the \emph{degree} of $C$, and for all $1\leq i\leq n$, $C_i$ is a decomposed condition and $u_i\colon I_i\ifunc A$ and $d_i\colon I_i\func A_i$ form a span of arrows from an interface $I_i$ to $A$, respectively the root $A_i$ of $C_i$.
\end{definition}
%
\emph{Terminology and notation:} As before, we use $A_C$ to denote the root of a decomposed condition, and $u^C_i,d^C_i,C_i$ for the elements of a branch $(u_i,d_i,C_i)$, omitting $C$ if this does not cause confusion. The degree of $C$ is denoted $\degr C$. $u_i$ stands for the \emph{up-arrow} (which is always mono) and $d_i$ for the \emph{down-arrow} of the interface $I_i$. Pictorially, $C$ can be visualised as in \fcite{decomposed condition}.
%
\begin{figure}
  \centering
  \input{figs/decomposed-condition}
  \caption{Pictorial representation of a decomposed condition}
  \flabel{decomposed condition}
\end{figure}
%
As we will see later, the morphisms $f_i$ of a nested condition can be reconstructed by taking the pushout over the spans $A_C\cnufi I_i\func A_{C_i}$.

\medskip\noindent\emph{Note to self: I like to try and find another term for ``decomposed condition''. Maybe ``split condition''?}

\medskip\noindent Decomposed conditions come with a modified notation of satisfaction.

\begin{definition}[satisfaction of decomposed conditions]\dlabel{decomposed satisfaction}
  Let $C$ be a decomposed condition and $g:A_C\func G$ an arrow from $C$'s root to an object $G$. We say that \emph{$g$ satisfies $C$}, denoted $g\sat C$, if there is a branch $(u,d,C')\in C$ and an arrow $h:A_{C'}\func G$ such that
  \begin{enumerate}
  \item $u;g=d;h$
  \item $h\nsat C'$.
  \end{enumerate}
\end{definition}
%

\emph{Terminology and notation.} Like before, we call $(u,d,C')\in C$ the \emph{responsible branch} and $h$ the \emph{witness} of $g\sat C$. Pictorially, $g\sat C$ with responsible branch $(u_i,d_i,C_i)$ and witness $h$ can be visualised as in \fcite{decomposed satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/decomposed-satisfaction}
  \caption{Pictorial representation of $g\sat C$ for a decomposed condition $C$}
  \flabel{decomposed satisfaction}
\end{figure}

Decomposed conditions have a notion of morphism.

\begin{definition}[decomposed condition morphism]\dlabel{decomposed morphism}
  Given two decomposed conditions $C,D$, a morphism $m$ from $C$ to $D$ is a pair $\tupof{t:A_C\func A_D,\setof{(k_i,m_i)}_{1\leq u\leq \degr C}}$ such that for all $1\leq i\leq \degr C$, there is a $1\leq j\leq \degr G$ with
  \begin{enumerate}
  \item $k_i$ an arrow from $I_j^D$ to $I_i^C$;
  \item $m_i$ a (decomposed condition) morphism from $D_j$ to $C_i$;
  \item $k_i;u_i^C;t_m=u_j^D$. (Note that this implies that $k_i$ is mono.)
  \item $k_i;d_i^C=d_j^D;t_{m_i}$.
  \end{enumerate}
\end{definition}
%
\emph{Notation and terminology:} If $C,D$ are decomposed conditions, we write $m:C\func D$ to denote that $m$ is a morphism from $C$ to $D$. We also write $t_m$ and $m_i$ for the components of $t$. Pictorially, $m$ can be visualised as in \fcite{decomposed morphism}.
%
\begin{figure}
  \centering
  \input{figs/decomposed-morphism}
  \caption{Pictorial representation of a decomposed condition morphism $m:C\func D$}
  \flabel{decomposed morphism}
\end{figure}

\medskip\noindent
\emph{Note to self: I find it surprising that there are no conditions on $k_i$ except for the confluence equations. For instance, $k_i,d_j^D$ is \emph{not} necessarily a pullback of $t_{m_i},d_i^C$ (\excite{no pullback} below); in fact, $k_i$ is \emph{not even} uniquely determined by the two confluence equations (\excite{k not unique} below); in other words, there may be multiple morphisms from $C$ to $D$ that only differ in their $k$ components. I am however not sure if $k$ itself should be part of the morphism, or we should merely require its existence.}

\medskip\noindent An important property of decomposed condition morphisms is that they \emph{preserve satisfaction}, in the following sense:
%
\begin{proposition}[morphisms preserve satisfaction]\plabel{morphism preserves satisfaction}
If $C,D$ are decomposed conditions with morphism $m:C\func D$, then $t_m;g\sat C$ implies $g\sat D$.
\end{proposition}
%
\emph{Proof.} By induction. Assume that $(u_i^C,d_i^C,C_i)$ is the branch of $C$ (hence the induction hypothesis is that the proposition holds for $C_i$) and $h^C\colon A_{C_i}\func G$ the morphism responsible for satisfaction; hence $u_i^C;t_m;g=d_i^C;h^C$ and $h^C\nsat C_i$. Moreover, let $(u_j^D,d_j^D,D_j)$ be the branch of $D$ with arrow $k_i\colon I_j^D\func I_i^C$ and morphism $m_i:D_j\func C_i$ as stipulated in \dcite{decomposed morphism}. This is visualised in \fcite{morphism preserves satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/morphism-preserves-satisfaction}
  \caption{$t_m;g\sat C$ with a morphism $m:C\rightarrow D$}
  \flabel{morphism preserves satisfaction}
\end{figure}

Now $h^D=t_{m_i};h^C$ can be shown to satisfy the conditions for $h$ in \dcite{decomposed satisfaction} to be a witness for $g\sat D_j$:
\begin{enumerate}
\item $u_j^D;g = k_i;u_i^C;t_m;g= k_i;d_i^C;h^C = d_j^D;t_{m_i};h^C=d_j^D;h^D$.
\item Suppose that $h^D\sat D_j$, meaning $t_{m_i};h^C\sat D_j$; then by the induction hypothesis and the fact that $m_i$ is a morphism, it follows that $h^C\sat C_i$, which is in contradiction with the initial assumption of this proof. Hence $h^D\nsat D_j$.
\end{enumerate}
%
\paragraph{Examples.}

Examples of entailment that we are able to show on the basis of the existence of a morphism are:
%
\begin{enumerate}
\item\exlabel{no pullback} $\phi\equiv \exists y\st a(x,y)$ entails $\psi\equiv \exists z,y\st a(z,y)$. Note the discrepancy of the free variables. The decomposed condition for $\psi$ must have $x$ in its root for a morphism to exist; however, the interface ``loses'' that $x$. Here's a visualisation of $C_\phi$ and $C_\psi$ as well as a morphism from the first to the second:

%  \begin{figure}
%    \centering
  \begin{center}
    \input{figs/ex-no-pullback}
  \end{center}
%    \caption{Illustration of \excite{no pullback}}
%      \flabel{no pullback}
%  \end{figure}
  
  \item\exlabel{non-trivial} $\psi\equiv \exists x\st a(x,y) \wedge \neg (\exists z\st b(y,z) \vee x=y)$ and $\psi\equiv \neg \exists x,z\st c(x,y)\wedge b(y,z)$. Here's a visualisation of $C_\phi$ and $C_\psi$ as well as a morphism from the first to the second:
%See \fcite{non-trivial} for a visualiation.
  
%  \begin{figure}
%    \centering
    \input{figs/ex-non-trivial}
%    \caption{Illustration of \excite{non-trivial}}
%      \flabel{non-trivial}
%  \end{figure}

  \item\exlabel{k not unique} $\phi\equiv x=y\wedge a(x,y)\wedge \neg \exists z\st b(y,z)$ and $\psi\equiv \neg\exists z\st b(x,z)\wedge b(y,z)$. The mediating arrow $k$ on the second (negated) level is not unique in this case; i.e., there exists more than one morphism from $C_\phi$ to $C_\psi$. This is essentially because in $\phi$ we know $x=y$, and hence these get merged into a single variable that can be mapped to either $x$ or $y$ in $\psi$. Here's a visualisation of $C_\phi$ and $C_\psi$ as well as a morphism from the first to the second:
 %See \fcite{k not unique} for a visualiation.
  
 % \begin{figure}
 %   \centering
  \begin{center}
    \input{figs/ex-k-not-unique}
  \end{center}
 %   \caption{Illustration of \excite{k not unique}}
 %   \flabel{k not unique}
 % \end{figure}
%
%% \item\exlabel{k unique} $\phi\equiv y\wedge \neg\exists z\st b(x,z)$ and $\psi\equiv x=y\wedge a(x,y)\wedge \neg \exists z\st b(y,z)$. This is a slight variation on \excite{k not unique} where, in this case, the mediating arrow $k$ \emph{is} unique: it must map the merged variable of $\psi$ to $x$ in $\phi$, because otherwise $b(x,z)$ (in $\psi$) has no image in $\phi$. See \fcite{k unique} for a visualiation.
%
%%   \begin{figure}
%%     \centering
%%     \input{figs/ex-k-unique}
%%     \caption{Illustration of \excite{k unique}}
%%     \flabel{k unique}
%%   \end{figure}
\end{enumerate}
%
An example of an interesting non-entailment for which a morphism fails to exist (as it should) is
%
\begin{enumerate}[resume]
\item\exlabel{non-entailment} $\phi=\exists x\st \neg\exists y\st a(x,y)$ and $\psi=\neg\exists z,y\st  a(z,y)$. Here's a visualisation of $C_\phi$ and $C_\psi$:
%See \fcite{non-entailment} for a visualiation.
  
%  \begin{figure}
  %    \centering
  \begin{center}
    \input{figs/ex-non-entailment}
  \end{center}
%    \caption{Illustration of \excite{non-entailment}}
%    \flabel{non-entailment}
%  \end{figure}
\end{enumerate}
%
An example of an entailment for which we do not have a morphism is
%
\begin{enumerate}[resume]
\item\exlabel{no-morphism} $\phi\equiv x\wedge \nexists y\st \neg a(x,y)$ and $\psi\equiv a(x,x)$. (Actually, this is a dressed-up version of $\phi$ versus $\neg\neg\phi$.) See \fcite{no-morphism} for a visualiation.
  
  \begin{figure}
    \centering
%    \input{figs/ex-no-morphism}
    \caption{Illustration of \excite{no-morphism}}
    \flabel{no-morphism}
  \end{figure}
\end{enumerate}


\subsection{Interface enrichment: A satisfaction invariant trasformation}

\begin{itemize}
  \item Remind to introduce ``condition branch''
  \item Shift of decomposed conditions along an arrow
  \item Prop(?): shift does not change satisfaction?
  \item Notation: given condition branch $C$ and interface $u = k;v$, we build $C_{\triangleleft k, v}$
  \item The construction
  \item Proposition: the contructions does not change satisfaction.
  \item Trasnforming a decomposed condition into an equivalent morphism-based one: apply the ``maximal'' enrichment top-bottom everywhere.
\end{itemize}  


\subsection{Decomposing nested conditions}




