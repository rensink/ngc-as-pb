\section{Span-based conditions}

We now present one the main idea of this paper based on the observation that there is a lot of duplication in a nested condition: the children of a node essentially contain all the structure of that (parent) node, and add some constraints on top of it. It turns out to be possible to avoid this duplication by only specifying the \emph{additional} structure. This is achieved by replacing the branch arrows $r_b$ by \emph{spans}.


\begin{definition}[span-based condition]\dlabel{sb-condition}
  Given a root object $R$:
  \begin{itemize}
  \item A \emph{span-based condition} over $R$ is a pair $(R,\cB)$ where $\cB\subseteq \SB R$ is a finite set of span-based branches over $R$.
  \item A \emph{span-based branch} over $R$ is a pair $(u,d,c)$ where $u:I\func R,d:I\func S$ is a span (with interface $I$) and $c\in \SC S$ is a span-based condition over $S$.
  \end{itemize}
\end{definition}
%
\emph{Terminology and notation:} As before, we use $R_c$ to denote the root of a span-based condition $c$, and $\cB_c$ to denote its set of branches. We also use $u_p,d_p,c_p$ to denote the elements of a branch $p$ (where $u_p$ stands for the \emph{up-arrow} and $d_p$ for the \emph{down-arrow} of $p$). Pictorially, $c$ can be visualised as in \fcite{sb-condition}.
%
\begin{figure}
  \centering
  \input{figs/sb-condition}
  \caption{Pictorial representation of a span-based condition}
  \flabel{sb-condition}
\end{figure}
%
As we will see later, the arrows $r_p$ of an arrow-based condition can be reconstructed by taking the pushout over the spans $R_c\cnuf I_p\func R_{c_p}$.

\medskip\noindent Span-based conditions come with a modified notation of satisfaction.

\begin{definition}[satisfaction of span-based conditions]\dlabel{sb-satisfaction}
  Let $c$ be a span-based condition and $g:R_c\func G$ an arrow from $c$'s root to an object $G$. We say that \emph{$g$ satisfies $c$}, denoted $g\sat c$, if there is a branch $p\in \cB_c$ and an arrow $h:R_{c_b}\func G$ such that
  \begin{enumerate}
  \item $u_p;g=d_p;h$
  \item $h\nsat c_p$.
  \end{enumerate}
\end{definition}
%
\emph{Terminology and notation.} Like before, we call $p\in\cB_c$ the \emph{responsible branch} and $h$ the \emph{witness} of $g\sat c$. Pictorially, $g\sat c$ with responsible branch $p$ and witness $h$ can be visualised as in \fcite{sb-satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/sb-satisfaction}
  \caption{Pictorial representation of $g\sat c$ for a span-based condition $c$}
  \flabel{sb-satisfaction}
\end{figure}

\medskip\noindent
Span-based conditions have a notion of morphism.

\begin{definition}[span-based condition morphism]\dlabel{sb-morphism}
  Given two span-based conditions $b,c$, a morphism $m$ from $b$ to $c$ is a pair $(t:R_b\func R_c,\setof{m_p}_{p\in \cB_b})$ such that for all $p\in \cB_b$, there is a $q\in \cB_c$ and an arrow $k_p:I_q\rightarrow I_p$ with
  \begin{enumerate}
  \item $m_p$ a (span-based condition) morphism from $c_q$ to $c_p$;
  \item $k_p;u_p;t_m=u_q$.
  \item $k_p;d_p=d_q;t_{m_p}$.
  \end{enumerate}
\end{definition}
%
\emph{Notation and terminology:} If $b,c$ are span-based conditions, we write $m:b\func c$ to denote that $m$ is a morphism from $b$ to $c$. We also write $t_m$ and $m_p$ (with $p\in\cB_c$) for the components of $m$. Pictorially, $m$ can be visualised as in \fcite{sb-morphism}.
%
\begin{figure}
  \centering
  \input{figs/sb-morphism}
  \caption{Pictorial representation of a span-based condition morphism $m:C\func D$}
  \flabel{sb-morphism}
\end{figure}

\medskip\noindent
\emph{Note to self: I find it surprising that there are no conditions on $k_i$ except for the confluence equations. For instance, $k_i,d_j^D$ is \emph{not} necessarily a pullback of $t_{m_i},d_i^C$ (\excite{no pullback} below); in fact, $k_i$ is \emph{not even} uniquely determined by the two confluence equations (\excite{k not unique} below); in other words, there may be multiple morphisms from $C$ to $D$ that only differ in their $k$ components. I am however not sure if $k$ itself should be part of the morphism, or we should merely require its existence.}

\medskip\noindent Span-based condition morphisms have the expected properties: identities and composition exist and form a monoid.

\begin{definition}[span-based condition identity morphism]
\end{definition}

\begin{definition}[span-based condition morphism composition]
  If $m_1:C_1\func C_2$ and $m_2:C_2\func C_3$ are morphisms with $m_i=\tupof{t_i,\setof{(k_{i,j},m_{i,j})}_{1\leq j\leq \degr{C_i}}}$ for $i=1,2$, then their composition $m_1;m_2$ is defined by $\tupof{t_1;t_2,\setof{(k'_j,m'_j)}_{1\leq j\leq \degr{C_1}}}$ with for all $1\leq j\leq \degr{C_1}$:
  \begin{itemize}
  \item $k'_j=k_{2,x_j};k_{1,j}$
  \item $m'_j=m_{2,x_j};m_{1,j}$
  \end{itemize}
  where $1\leq x_j\leq \degr{C_2}$ is such that $(k_{2,x_j},m_{2,x_j})$ is the element from $m_2$ 
\end{definition}

\begin{proposition}
\end{proposition}

\medskip\noindent An important property of span-based condition morphisms is that they \emph{preserve satisfaction}, in the following sense:
%
\begin{proposition}[morphisms preserve satisfaction]\plabel{morphism preserves satisfaction}
If $b,c$ are span-based conditions with morphism $m:b\func c$, then $t_m;g\sat b$ implies $g\sat c$.
\end{proposition}
%
\emph{Proof.} By induction. Assume that $p$ is the responsible branch of $C$ (hence the induction hypothesis implies that the proposition holds for $c_p$) and $h^b\colon R_{c_p}\func G$ the witness for $t_m;g\sat b$; hence $u_p;t_m;g=d_p;h^b$ and $h^b\nsat c_p$. Moreover, let $q$ be the branch of $c$ with arrow $k_p\colon I_q\func I_p$ and morphism $m_p:c_q\func c_p$ as stipulated in \dcite{sb-morphism}. This is visualised in \fcite{sb-morphism preserves satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/sb-morphism-preserves-satisfaction}
  \caption{$t_m;g\sat b$ with a morphism $m:b\rightarrow c$ implies $g\sat c$}
  \flabel{sb-morphism preserves satisfaction}
\end{figure}

Now $h^c=t_{m_p};h^b$ can be shown to satisfy the conditions for $h$ in \dcite{sb-satisfaction} to be a witness for $g\sat c$:
\begin{enumerate}
\item $u_q;g = k_p;u_p;t_m;g= k_p;d_p;h^b = d_q;t_{m_p};h^b=d_q;h^c$.
\item Suppose that $h^c\sat c_q$, meaning $t_{m_p};h^b\sat c_q$; then by the induction hypothesis and the fact that $m_p$ is a morphism from $c_q$ to $c_p$, it follows that $h^b\sat c_p$, which is in contradiction with the initial assumption of this proof. Hence $h^c\nsat c_q$.
\end{enumerate}

\subsection{From arrow-based to span-based conditions}

Span-based conditions are richer than arrow-based conditions. In this subsection we show the existence of a full, satisfaction-invariant functor from $\ABC_\bC$ to $\SBC_\bC$.

First, we inductively define the ``natural'' span-based conditon $\hat c$ for an arbitrary arrow-based condition $c$. Let $R\in\bC$.
\begin{itemize}
\item For an arbitrary $c=(R,\cB)\in \AC R$, let $\hat c=(R,\setof{\hat p}_{p\in\cB})$; 
\item For an arbitrary $p=(r,c)\in \AB R$, let $\hat p=(\id_R,r,\hat c)$.
\end{itemize}
%
It follows that $\hat c\in \SBC_\bC$ for all $c\in ABC_\bC$. In particular, an arrow-based branch $p=(r,c)$ (with root $R$) is translated to a span-based branch in which $R$ is the interface, and the span consists of up-arrow $\id_R$ and down-arrow $r$.

The structure of morphisms remains essentially identical. Let $b,c\in \ABC_\bC$.
%
\begin{itemize}
\item For an arbitrary $m:b\func c$ with $m=(t,\setof{m_p}_{p\in \cB_c})$, let $\hat m=(t,\setof{\hat m_p}_{\hat p\in \cB_{\hat c}})$.
\end{itemize}
%
\begin{proposition}
If $m:b\func c$ is an ab-morphism, then $\hat m:\hat b\func \hat c$ is an sb-morphism.
\end{proposition}
%
Now let $\cF$ map every $c\in \ABC_\bC$ to $\hat c$, and every $m\in \ABC_\bC(b,c)$ to $\hat m$.

\begin{theorem}
$\cF$ is a full functor from $\ABC_\bC$ to $\SBC_\cB$ such that, for all $c\in \ABC_\bC$ and all $g\in \bC$, $g\sat c$ if and only if $g\sat \cF(c)$.
\end{theorem}


\subsection{Interface enrichment: A satisfaction invariant trasformation}

\begin{itemize}
  \item Shift of span-based conditions along an arrow
  \item Prop(?): shift does not change satisfaction?
  \item Notation: given condition branch $C$ and interface $u = k;v$, we build $C_{\triangleleft k, v}$
  \item The construction
  \item Proposition: the contructions does not change satisfaction.
  \item Trasnforming a span-based condition into an equivalent arrow-based one: apply the ``maximal'' enrichment top-bottom everywhere.
\end{itemize}  


