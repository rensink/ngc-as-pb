\section{Span-based conditions}

We now present one the main idea of this paper based on the observation that there is a lot of duplication in a nested condition: the children of a node essentially contain all the structure of that (parent) node, and add some constraints on top of it. It turns out to be possible to avoid this duplication by only specifying the \emph{additional} structure (and how it is connected). This is achieved by replacing the branch arrows $r^c_i$ of a condition $c$ by \emph{spans}.

Span-based conditions are inductively defined as follows:

\begin{definition}[span-based condition]\dlabel{sb-condition}
  For any object $R$ of $\bC$, $\AC R$ (the set of \emph{arrow-based conditions} over $R$) and $\AB R$ (the set of \emph{arrow-based branches} over $R$) are the smallest sets such that
  \begin{itemize}
  \item $c\in \SC R$ if $c=(R,\bar p)$ where $\bar p\in \SB R^*$ is a finite sequence;
  \item $p\in \SB R$ if $p=(u,d,c)$ where $u: I\to R, d:I\func S$ form a span of arrows of $\bC$ and $c\in \SC S$.
  \end{itemize}
\end{definition}
%
\emph{Terminology and notation:} In a branch $p=(u,d,c)$, $u$ stands for the \emph{up-arrow} and $d$ for the \emph{down-arrow}. As before, we use $|c|=|\bar p|$ to denote the width of a span-based condition $c$, $R^c$ to denote its root, and $\bar p^c$ its branches (which are in practice always treated as an indexed set $\setof{p_i}_i$; the ordering is never used). We also use $p^c_i=(u^c_i,d^c_i,c_i)$ to denote the $i$'th branch of $c$ and its constituent elements (hence $\bar p^c=p^c_1\cdots p^c_{|c|}$). Finally, we use $I^c_i$ for the interface of branch $p^c_i$ and $R^c_i$ ($=R^{c_i}$) for the root of its subcondition (hence $u^c_i:I^c_i\func R^c$ and $d^c_i:I^c_i\rightarrow R^c_i$). In all these cases, we may omit the superscript $c$ if it is clear from the context. Pictorially, $c$ can be visualised as in \fcite{sb-condition}.
%
\begin{figure}
  \centering
  \input{figs/sb-condition}
  \caption{Pictorial representation of a span-based condition $c=(R,\bar p)$, with $\vec p=p_1\cdots p_n$ and $p_i=(u_i,d_i,c_i)$ for all $1\leq i\leq n$}
  \flabel{sb-condition}
\end{figure}
%
As we will see later, the arrows $r^c_i$ of an arrow-based condition can be reconstructed by taking the pushout over the spans $R^c\cnuf I^c_i\func R^c_i$.

\medskip\noindent Span-based conditions come with a modified notation of satisfaction.

\begin{definition}[satisfaction of span-based conditions]\dlabel{sb-satisfaction}
  Let $c$ be a span-based condition and $g:R\func G$ an arrow from $c$'s root to an object $G$. We say that \emph{$g$ satisfies $c$}, denoted $g\sat c$, if there is a branch $p_i$ and an arrow $h:R_i\func G$ such that
  \begin{enumerate}
  \item $u_i;g=d_i;h$
  \item $h\nsat c_i$.
  \end{enumerate}
\end{definition}
%
\emph{Terminology and notation.} Like before, we call $p_i$ the \emph{responsible branch} and $h$ the \emph{witness} of $g\sat c$. Pictorially, $g\sat c$ with responsible branch $p_i$ and witness $h$ can be visualised as in \fcite{sb-satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/sb-satisfaction}
  \caption{Pictorial representation of $g\sat c$ for a span-based condition $c$, with responsible branch $p_i=(u_i,d_i,c_i)$ and witness $h$}
  \flabel{sb-satisfaction}
\end{figure}

\medskip\noindent
Span-based conditions have a notion of morphism.

\begin{definition}[span-based condition morphism]\dlabel{sb-morphism}
  Given two sb-conditions $b,c$, an \emph{sb-morphism} $m:b\to c$ is a pair $(t,\setof{j_i,m_i}_{1\leq i\leq|b|})$ such that
  \begin{itemize}
  \item $t:R^b\func R^c$ is an arrow in $\bC$;  
  \item for all $1\leq i\leq |b|$:
    \begin{itemize}
    \item $1\leq j_i\leq |c|$ (and hence $p_{j_i}$ is a branch of $c$);
    \item $m_i:c_{j_i}\func b_i$ is an sb-condition morphism with top-level arrow $t_i$,
    \end{itemize}
    and there is an arrow $k_i:I^c_{j_i}\to I^b_i$ such that
    \begin{enumerate}
    \item $k_i;u^b_i;t=u^c_{j_i}$;
    \item $k_i;d^b_i=d^c_{j_i};t_i$.
    \end{enumerate}
  \end{itemize}
\end{definition}
%
\emph{Notation and terminology:} $t$ is called the top-level arrow of $m$. We write $t^m$ and (for all $\leq i\leq |b|$) $j^m_i$ and $m_i$ for the components of $m$, and $t^m_i$ for the top-level arrow of $m_i$. Pictorially, $m$ can be visualised as in \fcite{sb-morphism}.
%
\begin{figure}
  \centering
  \input{figs/sb-morphism}
  \caption{Pictorial representation of a span-based condition morphism $m:b\func c$ (with $n=|b|$ and $m=(t,\setof{j_i,m_i}_{1\leq i\leq n})$)}
  \flabel{sb-morphism}
\end{figure}

\medskip\noindent
\emph{Note to self: I find it surprising that there are no conditions on $k_p$ except for the confluence equations. For instance, $k_p,d_q$ is \emph{not} necessarily a pullback of $t_{m_p},d_p$ (\excite{no pullback} below); in fact, $k_p$ is \emph{not even} uniquely determined by the two confluence equations (\excite{k not unique} below). This is one of the reasons why the $k$ are not part of the morphism, but merely required to exist; otherwise there can be multiple morphisms between the same conditions that only differ in their $k$-components.}

\medskip\noindent Again, span-based condition morphisms have the expected properties: identities and composition exist and the categorical laws are satisfied, thus span-based conditions and their morphisms form a category.

\begin{proposition}[category \cat{SB-Cond}]
  The category $\cat{SB-Cond}$ having span-based conditions (\dcite{sb-condition}) as objects and span-based condition morphisms (\dcite{sb-morphism}) as arrows is well-defined.
\end{proposition}
 
\begin{proof}
  Given an sb-condition $c=(R,\vec p)$, the identity morphism $\id_c:c\func c$ is defined as $(\id_R,\setof{(i,\id_{c_i})}_{1\leq i\leq|c|})$: the required commutativity properties trivially hold by choosing $k_i=\id_{I_i}$.
  
Given two ab-condition morphisms $m= (t^m,\setof{(j^m_i,m_i)}_{1\leq i\leq |b|}):b\func c$ and $n = (t^n,\setof{(j^n_i,n_i)}_{1\leq i\leq |c|}):c\func e$, their composition is defined as $m;n=(t^m;t^n,\setof{(j^n_{j^m_i},n_{j^m_i};m_i)}_{1\leq i\leq |b|})$.
The well-definedness of $m;n$ can be proved in a standard way, choosing as intermediate morphisms $k_i=k^n_{j^m_i};k^m_i$ for all $1\leq i\leq |b|$.

The identity laws and associativity of composition can be proved in a standard way. \qed
\end{proof}
%
With this notion of morphism, we have the desired preservation of satisfaction, in the following sense:
%
\begin{proposition}[morphisms preserve satisfaction]\plabel{sb-morphisms preserve satisfaction}
Let $b$ and $c$ be span-based conditions. If $m:b\func c$ is an sb-condition morphism, then $t^m;g\sat b$ implies $g\sat c$ for all arrows $g:R^c\to G$.
\end{proposition}
%
\emph{Proof.} By induction. Assume that $p_i$ is the responsible branch of $b$ and $h^b\colon R_{c_p}\func G$ the witness for $t_m;g\sat b$; hence the induction hypothesis implies that the proposition holds for $c_i$, and moreover, $u^b_i;t;g=d^b_i;h^b$ and $h^b\nsat b_i$. Moreover, let $j=j_i$ and let $k\colon I^c_j\func I^b_i$ be as required in \dcite{sb-morphism}. This is visualised in \fcite{sb-morphism preserves satisfaction}.
%
\begin{figure}
  \centering
  \input{figs/sb-morphism-preserves-satisfaction}
  \caption{Given a morphism $m:b\rightarrow c$, $t;g\sat b$ implies $g\sat c$}
  \flabel{sb-morphism preserves satisfaction}
\end{figure}

Now $h^c=t_i;h^b$ can be shown to satisfy the conditions for $h$ in \dcite{sb-satisfaction} to be a witness for $g\sat c$, with responsible branch $p^c_j$:
\begin{enumerate}
\item $u^c_j;g = k_i;u^c_i;t;g= k_i;d^b_i;h^b = d^c_j;t_i;h^b=d^c_j;h^c$.
\item Suppose that $h^c\sat c_j$, meaning $t_i;h^b\sat c_j$; then by the induction hypothesis and the fact that $m_i$ is a morphism from $c_j$ to $b_i$, it follows that $h^b\sat b_i$, which is in contradiction with the initial assumption of this proof. Hence $h^c\nsat c_j$.
\end{enumerate}

\subsection{From arrow-based to span-based conditions}

Span-based conditions are richer than arrow-based conditions. In this subsection we show the existence of a full, satisfaction-invariant functor from $\ABC_\bC$ to $\SBC_\bC$.

First, we inductively define the ``natural'' span-based conditon $\hat c$ for an arbitrary arrow-based condition $c$. Let $R\in\bC$.
\begin{itemize}
\item For an arbitrary $c=(R,\cB)\in \AC R$, let $\hat c=(R,\setof{\hat p}_{p\in\cB})$; 
\item For an arbitrary $p=(r,c)\in \AB R$, let $\hat p=(\id_R,r,\hat c)$.
\end{itemize}
%
It follows that $\hat c\in \SBC_\bC$ for all $c\in ABC_\bC$. In particular, an arrow-based branch $p=(r,c)$ (with root $R$) is translated to a span-based branch in which $R$ is the interface, and the span consists of up-arrow $\id_R$ and down-arrow $r$.

The structure of morphisms remains essentially identical. Let $b,c\in \ABC_\bC$.
%
\begin{itemize}
\item For an arbitrary $m:b\func c$ with $m=(t,\setof{m_p}_{p\in \cB_c})$, let $\hat m=(t,\setof{\hat m_p}_{\hat p\in \cB_{\hat c}})$.
\end{itemize}
%
\begin{proposition}
If $m:b\func c$ is an ab-morphism, then $\hat m:\hat b\func \hat c$ is an sb-morphism.
\end{proposition}
%
Now let $\cF$ map every $c\in \ABC_\bC$ to $\hat c$, and every $m\in \ABC_\bC(b,c)$ to $\hat m$.

\begin{theorem}
$\cF$ is a full functor from $\ABC_\bC$ to $\SBC_\cB$ such that, for all $c\in \ABC_\bC$ and all $g\in \bC$, $g\sat c$ if and only if $g\sat \cF(c)$.
\end{theorem}




